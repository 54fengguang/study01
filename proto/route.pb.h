// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_route_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_route_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_route_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_route_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_route_2eproto;
namespace haoxing {
namespace route {
class FieldInfo;
struct FieldInfoDefaultTypeInternal;
extern FieldInfoDefaultTypeInternal _FieldInfo_default_instance_;
class Implement;
struct ImplementDefaultTypeInternal;
extern ImplementDefaultTypeInternal _Implement_default_instance_;
class NodeXYZ;
struct NodeXYZDefaultTypeInternal;
extern NodeXYZDefaultTypeInternal _NodeXYZ_default_instance_;
class Obstacle;
struct ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class PlanParam;
struct PlanParamDefaultTypeInternal;
extern PlanParamDefaultTypeInternal _PlanParam_default_instance_;
class RequestParam;
struct RequestParamDefaultTypeInternal;
extern RequestParamDefaultTypeInternal _RequestParam_default_instance_;
class ResponseParam;
struct ResponseParamDefaultTypeInternal;
extern ResponseParamDefaultTypeInternal _ResponseParam_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace route
}  // namespace haoxing
PROTOBUF_NAMESPACE_OPEN
template<> ::haoxing::route::FieldInfo* Arena::CreateMaybeMessage<::haoxing::route::FieldInfo>(Arena*);
template<> ::haoxing::route::Implement* Arena::CreateMaybeMessage<::haoxing::route::Implement>(Arena*);
template<> ::haoxing::route::NodeXYZ* Arena::CreateMaybeMessage<::haoxing::route::NodeXYZ>(Arena*);
template<> ::haoxing::route::Obstacle* Arena::CreateMaybeMessage<::haoxing::route::Obstacle>(Arena*);
template<> ::haoxing::route::PlanParam* Arena::CreateMaybeMessage<::haoxing::route::PlanParam>(Arena*);
template<> ::haoxing::route::RequestParam* Arena::CreateMaybeMessage<::haoxing::route::RequestParam>(Arena*);
template<> ::haoxing::route::ResponseParam* Arena::CreateMaybeMessage<::haoxing::route::ResponseParam>(Arena*);
template<> ::haoxing::route::Vehicle* Arena::CreateMaybeMessage<::haoxing::route::Vehicle>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace haoxing {
namespace route {

// ===================================================================

class NodeXYZ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.NodeXYZ) */ {
 public:
  inline NodeXYZ() : NodeXYZ(nullptr) {}
  ~NodeXYZ() override;
  explicit PROTOBUF_CONSTEXPR NodeXYZ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeXYZ(const NodeXYZ& from);
  NodeXYZ(NodeXYZ&& from) noexcept
    : NodeXYZ() {
    *this = ::std::move(from);
  }

  inline NodeXYZ& operator=(const NodeXYZ& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeXYZ& operator=(NodeXYZ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeXYZ& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeXYZ* internal_default_instance() {
    return reinterpret_cast<const NodeXYZ*>(
               &_NodeXYZ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NodeXYZ& a, NodeXYZ& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeXYZ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeXYZ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeXYZ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeXYZ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeXYZ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeXYZ& from) {
    NodeXYZ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeXYZ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.NodeXYZ";
  }
  protected:
  explicit NodeXYZ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kYawFieldNumber = 4,
    kCurvatureFieldNumber = 5,
    kSegmentFieldNumber = 6,
    kReverseFieldNumber = 7,
    kNodeTypeFieldNumber = 8,
    kImplStateFieldNumber = 9,
    kImplPloughOriFieldNumber = 10,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double yaw = 4;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // double curvature = 5;
  void clear_curvature();
  double curvature() const;
  void set_curvature(double value);
  private:
  double _internal_curvature() const;
  void _internal_set_curvature(double value);
  public:

  // int32 segment = 6;
  void clear_segment();
  int32_t segment() const;
  void set_segment(int32_t value);
  private:
  int32_t _internal_segment() const;
  void _internal_set_segment(int32_t value);
  public:

  // bool reverse = 7;
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // int32 node_type = 8;
  void clear_node_type();
  int32_t node_type() const;
  void set_node_type(int32_t value);
  private:
  int32_t _internal_node_type() const;
  void _internal_set_node_type(int32_t value);
  public:

  // int32 impl_state = 9;
  void clear_impl_state();
  int32_t impl_state() const;
  void set_impl_state(int32_t value);
  private:
  int32_t _internal_impl_state() const;
  void _internal_set_impl_state(int32_t value);
  public:

  // int32 impl_plough_ori = 10;
  void clear_impl_plough_ori();
  int32_t impl_plough_ori() const;
  void set_impl_plough_ori(int32_t value);
  private:
  int32_t _internal_impl_plough_ori() const;
  void _internal_set_impl_plough_ori(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.NodeXYZ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    double yaw_;
    double curvature_;
    int32_t segment_;
    bool reverse_;
    int32_t node_type_;
    int32_t impl_state_;
    int32_t impl_plough_ori_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class FieldInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.FieldInfo) */ {
 public:
  inline FieldInfo() : FieldInfo(nullptr) {}
  ~FieldInfo() override;
  explicit PROTOBUF_CONSTEXPR FieldInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldInfo(const FieldInfo& from);
  FieldInfo(FieldInfo&& from) noexcept
    : FieldInfo() {
    *this = ::std::move(from);
  }

  inline FieldInfo& operator=(const FieldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldInfo& operator=(FieldInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldInfo* internal_default_instance() {
    return reinterpret_cast<const FieldInfo*>(
               &_FieldInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FieldInfo& a, FieldInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldInfo& from) {
    FieldInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.FieldInfo";
  }
  protected:
  explicit FieldInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNodesFieldNumber = 3,
    kObstaclesFieldNumber = 4,
    kPresetSpacesFieldNumber = 5,
    kEntranceNodeFieldNumber = 1,
    kExitNodeFieldNumber = 2,
  };
  // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
  int fieldnodes_size() const;
  private:
  int _internal_fieldnodes_size() const;
  public:
  void clear_fieldnodes();
  ::haoxing::route::NodeXYZ* mutable_fieldnodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
      mutable_fieldnodes();
  private:
  const ::haoxing::route::NodeXYZ& _internal_fieldnodes(int index) const;
  ::haoxing::route::NodeXYZ* _internal_add_fieldnodes();
  public:
  const ::haoxing::route::NodeXYZ& fieldnodes(int index) const;
  ::haoxing::route::NodeXYZ* add_fieldnodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
      fieldnodes() const;

  // repeated .haoxing.route.Obstacle obstacles = 4;
  int obstacles_size() const;
  private:
  int _internal_obstacles_size() const;
  public:
  void clear_obstacles();
  ::haoxing::route::Obstacle* mutable_obstacles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::Obstacle >*
      mutable_obstacles();
  private:
  const ::haoxing::route::Obstacle& _internal_obstacles(int index) const;
  ::haoxing::route::Obstacle* _internal_add_obstacles();
  public:
  const ::haoxing::route::Obstacle& obstacles(int index) const;
  ::haoxing::route::Obstacle* add_obstacles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::Obstacle >&
      obstacles() const;

  // repeated double preset_spaces = 5;
  int preset_spaces_size() const;
  private:
  int _internal_preset_spaces_size() const;
  public:
  void clear_preset_spaces();
  private:
  double _internal_preset_spaces(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_preset_spaces() const;
  void _internal_add_preset_spaces(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_preset_spaces();
  public:
  double preset_spaces(int index) const;
  void set_preset_spaces(int index, double value);
  void add_preset_spaces(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      preset_spaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_preset_spaces();

  // .haoxing.route.NodeXYZ entrance_node = 1;
  bool has_entrance_node() const;
  private:
  bool _internal_has_entrance_node() const;
  public:
  void clear_entrance_node();
  const ::haoxing::route::NodeXYZ& entrance_node() const;
  PROTOBUF_NODISCARD ::haoxing::route::NodeXYZ* release_entrance_node();
  ::haoxing::route::NodeXYZ* mutable_entrance_node();
  void set_allocated_entrance_node(::haoxing::route::NodeXYZ* entrance_node);
  private:
  const ::haoxing::route::NodeXYZ& _internal_entrance_node() const;
  ::haoxing::route::NodeXYZ* _internal_mutable_entrance_node();
  public:
  void unsafe_arena_set_allocated_entrance_node(
      ::haoxing::route::NodeXYZ* entrance_node);
  ::haoxing::route::NodeXYZ* unsafe_arena_release_entrance_node();

  // .haoxing.route.NodeXYZ exit_node = 2;
  bool has_exit_node() const;
  private:
  bool _internal_has_exit_node() const;
  public:
  void clear_exit_node();
  const ::haoxing::route::NodeXYZ& exit_node() const;
  PROTOBUF_NODISCARD ::haoxing::route::NodeXYZ* release_exit_node();
  ::haoxing::route::NodeXYZ* mutable_exit_node();
  void set_allocated_exit_node(::haoxing::route::NodeXYZ* exit_node);
  private:
  const ::haoxing::route::NodeXYZ& _internal_exit_node() const;
  ::haoxing::route::NodeXYZ* _internal_mutable_exit_node();
  public:
  void unsafe_arena_set_allocated_exit_node(
      ::haoxing::route::NodeXYZ* exit_node);
  ::haoxing::route::NodeXYZ* unsafe_arena_release_exit_node();

  // @@protoc_insertion_point(class_scope:haoxing.route.FieldInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ > fieldnodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::Obstacle > obstacles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > preset_spaces_;
    ::haoxing::route::NodeXYZ* entrance_node_;
    ::haoxing::route::NodeXYZ* exit_node_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class PlanParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.PlanParam) */ {
 public:
  inline PlanParam() : PlanParam(nullptr) {}
  ~PlanParam() override;
  explicit PROTOBUF_CONSTEXPR PlanParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanParam(const PlanParam& from);
  PlanParam(PlanParam&& from) noexcept
    : PlanParam() {
    *this = ::std::move(from);
  }

  inline PlanParam& operator=(const PlanParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanParam& operator=(PlanParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanParam* internal_default_instance() {
    return reinterpret_cast<const PlanParam*>(
               &_PlanParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PlanParam& a, PlanParam& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanParam& from) {
    PlanParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.PlanParam";
  }
  protected:
  explicit PlanParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskVehicleNumFieldNumber = 7,
    kServiceNodesFieldNumber = 8,
    kInterSpFieldNumber = 1,
    kRouteTypeFieldNumber = 2,
    kTaskTypeFieldNumber = 3,
    kModifyOrientationFieldNumber = 4,
    kAccOverlapFieldNumber = 5,
    kMultiVehicleFieldNumber = 6,
  };
  // repeated int32 task_vehicle_num = 7;
  int task_vehicle_num_size() const;
  private:
  int _internal_task_vehicle_num_size() const;
  public:
  void clear_task_vehicle_num();
  private:
  int32_t _internal_task_vehicle_num(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_task_vehicle_num() const;
  void _internal_add_task_vehicle_num(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_task_vehicle_num();
  public:
  int32_t task_vehicle_num(int index) const;
  void set_task_vehicle_num(int index, int32_t value);
  void add_task_vehicle_num(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      task_vehicle_num() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_task_vehicle_num();

  // repeated .haoxing.route.NodeXYZ service_nodes = 8;
  int service_nodes_size() const;
  private:
  int _internal_service_nodes_size() const;
  public:
  void clear_service_nodes();
  ::haoxing::route::NodeXYZ* mutable_service_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
      mutable_service_nodes();
  private:
  const ::haoxing::route::NodeXYZ& _internal_service_nodes(int index) const;
  ::haoxing::route::NodeXYZ* _internal_add_service_nodes();
  public:
  const ::haoxing::route::NodeXYZ& service_nodes(int index) const;
  ::haoxing::route::NodeXYZ* add_service_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
      service_nodes() const;

  // double inter_sp = 1;
  void clear_inter_sp();
  double inter_sp() const;
  void set_inter_sp(double value);
  private:
  double _internal_inter_sp() const;
  void _internal_set_inter_sp(double value);
  public:

  // double route_type = 2;
  void clear_route_type();
  double route_type() const;
  void set_route_type(double value);
  private:
  double _internal_route_type() const;
  void _internal_set_route_type(double value);
  public:

  // double task_type = 3;
  void clear_task_type();
  double task_type() const;
  void set_task_type(double value);
  private:
  double _internal_task_type() const;
  void _internal_set_task_type(double value);
  public:

  // bool modify_orientation = 4;
  void clear_modify_orientation();
  bool modify_orientation() const;
  void set_modify_orientation(bool value);
  private:
  bool _internal_modify_orientation() const;
  void _internal_set_modify_orientation(bool value);
  public:

  // bool acc_overlap = 5;
  void clear_acc_overlap();
  bool acc_overlap() const;
  void set_acc_overlap(bool value);
  private:
  bool _internal_acc_overlap() const;
  void _internal_set_acc_overlap(bool value);
  public:

  // bool multi_vehicle = 6;
  void clear_multi_vehicle();
  bool multi_vehicle() const;
  void set_multi_vehicle(bool value);
  private:
  bool _internal_multi_vehicle() const;
  void _internal_set_multi_vehicle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.PlanParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > task_vehicle_num_;
    mutable std::atomic<int> _task_vehicle_num_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ > service_nodes_;
    double inter_sp_;
    double route_type_;
    double task_type_;
    bool modify_orientation_;
    bool acc_overlap_;
    bool multi_vehicle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class Vehicle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  explicit PROTOBUF_CONSTEXPR Vehicle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.Vehicle";
  }
  protected:
  explicit Vehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kOverAllWidthFieldNumber = 3,
    kFrontEndToLocationFieldNumber = 4,
    kRearEndToLocationFieldNumber = 5,
    kWheelBaseFieldNumber = 6,
    kRadiusFieldNumber = 7,
    kReverseFieldNumber = 2,
  };
  // double length = 1;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // double over_all_width = 3;
  void clear_over_all_width();
  double over_all_width() const;
  void set_over_all_width(double value);
  private:
  double _internal_over_all_width() const;
  void _internal_set_over_all_width(double value);
  public:

  // double front_end_to_location = 4;
  void clear_front_end_to_location();
  double front_end_to_location() const;
  void set_front_end_to_location(double value);
  private:
  double _internal_front_end_to_location() const;
  void _internal_set_front_end_to_location(double value);
  public:

  // double rear_end_to_location = 5;
  void clear_rear_end_to_location();
  double rear_end_to_location() const;
  void set_rear_end_to_location(double value);
  private:
  double _internal_rear_end_to_location() const;
  void _internal_set_rear_end_to_location(double value);
  public:

  // double wheel_base = 6;
  void clear_wheel_base();
  double wheel_base() const;
  void set_wheel_base(double value);
  private:
  double _internal_wheel_base() const;
  void _internal_set_wheel_base(double value);
  public:

  // double radius = 7;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // bool reverse = 2;
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.Vehicle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double length_;
    double over_all_width_;
    double front_end_to_location_;
    double rear_end_to_location_;
    double wheel_base_;
    double radius_;
    bool reverse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class Implement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.Implement) */ {
 public:
  inline Implement() : Implement(nullptr) {}
  ~Implement() override;
  explicit PROTOBUF_CONSTEXPR Implement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Implement(const Implement& from);
  Implement(Implement&& from) noexcept
    : Implement() {
    *this = ::std::move(from);
  }

  inline Implement& operator=(const Implement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Implement& operator=(Implement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Implement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Implement* internal_default_instance() {
    return reinterpret_cast<const Implement*>(
               &_Implement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Implement& a, Implement& b) {
    a.Swap(&b);
  }
  inline void Swap(Implement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Implement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Implement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Implement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Implement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Implement& from) {
    Implement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Implement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.Implement";
  }
  protected:
  explicit Implement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kLengthFieldNumber = 2,
    kRightOffsetFieldNumber = 3,
    kLeftOffsetFieldNumber = 4,
    kLinkageModeFieldNumber = 5,
  };
  // double width = 1;
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // double length = 2;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // double right_offset = 3;
  void clear_right_offset();
  double right_offset() const;
  void set_right_offset(double value);
  private:
  double _internal_right_offset() const;
  void _internal_set_right_offset(double value);
  public:

  // double left_offset = 4;
  void clear_left_offset();
  double left_offset() const;
  void set_left_offset(double value);
  private:
  double _internal_left_offset() const;
  void _internal_set_left_offset(double value);
  public:

  // int32 linkage_mode = 5;
  void clear_linkage_mode();
  int32_t linkage_mode() const;
  void set_linkage_mode(int32_t value);
  private:
  int32_t _internal_linkage_mode() const;
  void _internal_set_linkage_mode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.Implement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double width_;
    double length_;
    double right_offset_;
    double left_offset_;
    int32_t linkage_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class Obstacle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.Obstacle) */ {
 public:
  inline Obstacle() : Obstacle(nullptr) {}
  ~Obstacle() override;
  explicit PROTOBUF_CONSTEXPR Obstacle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Obstacle(const Obstacle& from);
  Obstacle(Obstacle&& from) noexcept
    : Obstacle() {
    *this = ::std::move(from);
  }

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacle& operator=(Obstacle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Obstacle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Obstacle* internal_default_instance() {
    return reinterpret_cast<const Obstacle*>(
               &_Obstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Obstacle& a, Obstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Obstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Obstacle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Obstacle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Obstacle& from) {
    Obstacle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.Obstacle";
  }
  protected:
  explicit Obstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kRFieldNumber = 4,
    kRWFieldNumber = 5,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double r = 4;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double r_w = 5;
  void clear_r_w();
  double r_w() const;
  void set_r_w(double value);
  private:
  double _internal_r_w() const;
  void _internal_set_r_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.Obstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    double r_;
    double r_w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RequestParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.RequestParam) */ {
 public:
  inline RequestParam() : RequestParam(nullptr) {}
  ~RequestParam() override;
  explicit PROTOBUF_CONSTEXPR RequestParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestParam(const RequestParam& from);
  RequestParam(RequestParam&& from) noexcept
    : RequestParam() {
    *this = ::std::move(from);
  }

  inline RequestParam& operator=(const RequestParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestParam& operator=(RequestParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestParam* internal_default_instance() {
    return reinterpret_cast<const RequestParam*>(
               &_RequestParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestParam& a, RequestParam& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestParam& from) {
    RequestParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.RequestParam";
  }
  protected:
  explicit RequestParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldInfosFieldNumber = 1,
    kPlanParamFieldNumber = 2,
    kVehicleFieldNumber = 3,
    kImplementFieldNumber = 4,
  };
  // repeated .haoxing.route.FieldInfo field_infos = 1;
  int field_infos_size() const;
  private:
  int _internal_field_infos_size() const;
  public:
  void clear_field_infos();
  ::haoxing::route::FieldInfo* mutable_field_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::FieldInfo >*
      mutable_field_infos();
  private:
  const ::haoxing::route::FieldInfo& _internal_field_infos(int index) const;
  ::haoxing::route::FieldInfo* _internal_add_field_infos();
  public:
  const ::haoxing::route::FieldInfo& field_infos(int index) const;
  ::haoxing::route::FieldInfo* add_field_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::FieldInfo >&
      field_infos() const;

  // .haoxing.route.PlanParam plan_param = 2;
  bool has_plan_param() const;
  private:
  bool _internal_has_plan_param() const;
  public:
  void clear_plan_param();
  const ::haoxing::route::PlanParam& plan_param() const;
  PROTOBUF_NODISCARD ::haoxing::route::PlanParam* release_plan_param();
  ::haoxing::route::PlanParam* mutable_plan_param();
  void set_allocated_plan_param(::haoxing::route::PlanParam* plan_param);
  private:
  const ::haoxing::route::PlanParam& _internal_plan_param() const;
  ::haoxing::route::PlanParam* _internal_mutable_plan_param();
  public:
  void unsafe_arena_set_allocated_plan_param(
      ::haoxing::route::PlanParam* plan_param);
  ::haoxing::route::PlanParam* unsafe_arena_release_plan_param();

  // .haoxing.route.Vehicle vehicle = 3;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::haoxing::route::Vehicle& vehicle() const;
  PROTOBUF_NODISCARD ::haoxing::route::Vehicle* release_vehicle();
  ::haoxing::route::Vehicle* mutable_vehicle();
  void set_allocated_vehicle(::haoxing::route::Vehicle* vehicle);
  private:
  const ::haoxing::route::Vehicle& _internal_vehicle() const;
  ::haoxing::route::Vehicle* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::haoxing::route::Vehicle* vehicle);
  ::haoxing::route::Vehicle* unsafe_arena_release_vehicle();

  // .haoxing.route.Implement implement = 4;
  bool has_implement() const;
  private:
  bool _internal_has_implement() const;
  public:
  void clear_implement();
  const ::haoxing::route::Implement& implement() const;
  PROTOBUF_NODISCARD ::haoxing::route::Implement* release_implement();
  ::haoxing::route::Implement* mutable_implement();
  void set_allocated_implement(::haoxing::route::Implement* implement);
  private:
  const ::haoxing::route::Implement& _internal_implement() const;
  ::haoxing::route::Implement* _internal_mutable_implement();
  public:
  void unsafe_arena_set_allocated_implement(
      ::haoxing::route::Implement* implement);
  ::haoxing::route::Implement* unsafe_arena_release_implement();

  // @@protoc_insertion_point(class_scope:haoxing.route.RequestParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::FieldInfo > field_infos_;
    ::haoxing::route::PlanParam* plan_param_;
    ::haoxing::route::Vehicle* vehicle_;
    ::haoxing::route::Implement* implement_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class ResponseParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.ResponseParam) */ {
 public:
  inline ResponseParam() : ResponseParam(nullptr) {}
  ~ResponseParam() override;
  explicit PROTOBUF_CONSTEXPR ResponseParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseParam(const ResponseParam& from);
  ResponseParam(ResponseParam&& from) noexcept
    : ResponseParam() {
    *this = ::std::move(from);
  }

  inline ResponseParam& operator=(const ResponseParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseParam& operator=(ResponseParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseParam* internal_default_instance() {
    return reinterpret_cast<const ResponseParam*>(
               &_ResponseParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResponseParam& a, ResponseParam& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseParam& from) {
    ResponseParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.ResponseParam";
  }
  protected:
  explicit ResponseParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kMileageFieldNumber = 2,
  };
  // repeated .haoxing.route.NodeXYZ nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::haoxing::route::NodeXYZ* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
      mutable_nodes();
  private:
  const ::haoxing::route::NodeXYZ& _internal_nodes(int index) const;
  ::haoxing::route::NodeXYZ* _internal_add_nodes();
  public:
  const ::haoxing::route::NodeXYZ& nodes(int index) const;
  ::haoxing::route::NodeXYZ* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
      nodes() const;

  // double mileage = 2;
  void clear_mileage();
  double mileage() const;
  void set_mileage(double value);
  private:
  double _internal_mileage() const;
  void _internal_set_mileage(double value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.ResponseParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ > nodes_;
    double mileage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NodeXYZ

// double x = 1;
inline void NodeXYZ::clear_x() {
  _impl_.x_ = 0;
}
inline double NodeXYZ::_internal_x() const {
  return _impl_.x_;
}
inline double NodeXYZ::x() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.x)
  return _internal_x();
}
inline void NodeXYZ::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void NodeXYZ::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.x)
}

// double y = 2;
inline void NodeXYZ::clear_y() {
  _impl_.y_ = 0;
}
inline double NodeXYZ::_internal_y() const {
  return _impl_.y_;
}
inline double NodeXYZ::y() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.y)
  return _internal_y();
}
inline void NodeXYZ::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void NodeXYZ::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.y)
}

// double z = 3;
inline void NodeXYZ::clear_z() {
  _impl_.z_ = 0;
}
inline double NodeXYZ::_internal_z() const {
  return _impl_.z_;
}
inline double NodeXYZ::z() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.z)
  return _internal_z();
}
inline void NodeXYZ::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void NodeXYZ::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.z)
}

// double yaw = 4;
inline void NodeXYZ::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline double NodeXYZ::_internal_yaw() const {
  return _impl_.yaw_;
}
inline double NodeXYZ::yaw() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.yaw)
  return _internal_yaw();
}
inline void NodeXYZ::_internal_set_yaw(double value) {
  
  _impl_.yaw_ = value;
}
inline void NodeXYZ::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.yaw)
}

// double curvature = 5;
inline void NodeXYZ::clear_curvature() {
  _impl_.curvature_ = 0;
}
inline double NodeXYZ::_internal_curvature() const {
  return _impl_.curvature_;
}
inline double NodeXYZ::curvature() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.curvature)
  return _internal_curvature();
}
inline void NodeXYZ::_internal_set_curvature(double value) {
  
  _impl_.curvature_ = value;
}
inline void NodeXYZ::set_curvature(double value) {
  _internal_set_curvature(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.curvature)
}

// int32 segment = 6;
inline void NodeXYZ::clear_segment() {
  _impl_.segment_ = 0;
}
inline int32_t NodeXYZ::_internal_segment() const {
  return _impl_.segment_;
}
inline int32_t NodeXYZ::segment() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.segment)
  return _internal_segment();
}
inline void NodeXYZ::_internal_set_segment(int32_t value) {
  
  _impl_.segment_ = value;
}
inline void NodeXYZ::set_segment(int32_t value) {
  _internal_set_segment(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.segment)
}

// bool reverse = 7;
inline void NodeXYZ::clear_reverse() {
  _impl_.reverse_ = false;
}
inline bool NodeXYZ::_internal_reverse() const {
  return _impl_.reverse_;
}
inline bool NodeXYZ::reverse() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.reverse)
  return _internal_reverse();
}
inline void NodeXYZ::_internal_set_reverse(bool value) {
  
  _impl_.reverse_ = value;
}
inline void NodeXYZ::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.reverse)
}

// int32 node_type = 8;
inline void NodeXYZ::clear_node_type() {
  _impl_.node_type_ = 0;
}
inline int32_t NodeXYZ::_internal_node_type() const {
  return _impl_.node_type_;
}
inline int32_t NodeXYZ::node_type() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.node_type)
  return _internal_node_type();
}
inline void NodeXYZ::_internal_set_node_type(int32_t value) {
  
  _impl_.node_type_ = value;
}
inline void NodeXYZ::set_node_type(int32_t value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.node_type)
}

// int32 impl_state = 9;
inline void NodeXYZ::clear_impl_state() {
  _impl_.impl_state_ = 0;
}
inline int32_t NodeXYZ::_internal_impl_state() const {
  return _impl_.impl_state_;
}
inline int32_t NodeXYZ::impl_state() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.impl_state)
  return _internal_impl_state();
}
inline void NodeXYZ::_internal_set_impl_state(int32_t value) {
  
  _impl_.impl_state_ = value;
}
inline void NodeXYZ::set_impl_state(int32_t value) {
  _internal_set_impl_state(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.impl_state)
}

// int32 impl_plough_ori = 10;
inline void NodeXYZ::clear_impl_plough_ori() {
  _impl_.impl_plough_ori_ = 0;
}
inline int32_t NodeXYZ::_internal_impl_plough_ori() const {
  return _impl_.impl_plough_ori_;
}
inline int32_t NodeXYZ::impl_plough_ori() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.impl_plough_ori)
  return _internal_impl_plough_ori();
}
inline void NodeXYZ::_internal_set_impl_plough_ori(int32_t value) {
  
  _impl_.impl_plough_ori_ = value;
}
inline void NodeXYZ::set_impl_plough_ori(int32_t value) {
  _internal_set_impl_plough_ori(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.impl_plough_ori)
}

// -------------------------------------------------------------------

// FieldInfo

// .haoxing.route.NodeXYZ entrance_node = 1;
inline bool FieldInfo::_internal_has_entrance_node() const {
  return this != internal_default_instance() && _impl_.entrance_node_ != nullptr;
}
inline bool FieldInfo::has_entrance_node() const {
  return _internal_has_entrance_node();
}
inline void FieldInfo::clear_entrance_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.entrance_node_ != nullptr) {
    delete _impl_.entrance_node_;
  }
  _impl_.entrance_node_ = nullptr;
}
inline const ::haoxing::route::NodeXYZ& FieldInfo::_internal_entrance_node() const {
  const ::haoxing::route::NodeXYZ* p = _impl_.entrance_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::NodeXYZ&>(
      ::haoxing::route::_NodeXYZ_default_instance_);
}
inline const ::haoxing::route::NodeXYZ& FieldInfo::entrance_node() const {
  // @@protoc_insertion_point(field_get:haoxing.route.FieldInfo.entrance_node)
  return _internal_entrance_node();
}
inline void FieldInfo::unsafe_arena_set_allocated_entrance_node(
    ::haoxing::route::NodeXYZ* entrance_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entrance_node_);
  }
  _impl_.entrance_node_ = entrance_node;
  if (entrance_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.FieldInfo.entrance_node)
}
inline ::haoxing::route::NodeXYZ* FieldInfo::release_entrance_node() {
  
  ::haoxing::route::NodeXYZ* temp = _impl_.entrance_node_;
  _impl_.entrance_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::NodeXYZ* FieldInfo::unsafe_arena_release_entrance_node() {
  // @@protoc_insertion_point(field_release:haoxing.route.FieldInfo.entrance_node)
  
  ::haoxing::route::NodeXYZ* temp = _impl_.entrance_node_;
  _impl_.entrance_node_ = nullptr;
  return temp;
}
inline ::haoxing::route::NodeXYZ* FieldInfo::_internal_mutable_entrance_node() {
  
  if (_impl_.entrance_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::NodeXYZ>(GetArenaForAllocation());
    _impl_.entrance_node_ = p;
  }
  return _impl_.entrance_node_;
}
inline ::haoxing::route::NodeXYZ* FieldInfo::mutable_entrance_node() {
  ::haoxing::route::NodeXYZ* _msg = _internal_mutable_entrance_node();
  // @@protoc_insertion_point(field_mutable:haoxing.route.FieldInfo.entrance_node)
  return _msg;
}
inline void FieldInfo::set_allocated_entrance_node(::haoxing::route::NodeXYZ* entrance_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.entrance_node_;
  }
  if (entrance_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entrance_node);
    if (message_arena != submessage_arena) {
      entrance_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entrance_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.entrance_node_ = entrance_node;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.FieldInfo.entrance_node)
}

// .haoxing.route.NodeXYZ exit_node = 2;
inline bool FieldInfo::_internal_has_exit_node() const {
  return this != internal_default_instance() && _impl_.exit_node_ != nullptr;
}
inline bool FieldInfo::has_exit_node() const {
  return _internal_has_exit_node();
}
inline void FieldInfo::clear_exit_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.exit_node_ != nullptr) {
    delete _impl_.exit_node_;
  }
  _impl_.exit_node_ = nullptr;
}
inline const ::haoxing::route::NodeXYZ& FieldInfo::_internal_exit_node() const {
  const ::haoxing::route::NodeXYZ* p = _impl_.exit_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::NodeXYZ&>(
      ::haoxing::route::_NodeXYZ_default_instance_);
}
inline const ::haoxing::route::NodeXYZ& FieldInfo::exit_node() const {
  // @@protoc_insertion_point(field_get:haoxing.route.FieldInfo.exit_node)
  return _internal_exit_node();
}
inline void FieldInfo::unsafe_arena_set_allocated_exit_node(
    ::haoxing::route::NodeXYZ* exit_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exit_node_);
  }
  _impl_.exit_node_ = exit_node;
  if (exit_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.FieldInfo.exit_node)
}
inline ::haoxing::route::NodeXYZ* FieldInfo::release_exit_node() {
  
  ::haoxing::route::NodeXYZ* temp = _impl_.exit_node_;
  _impl_.exit_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::NodeXYZ* FieldInfo::unsafe_arena_release_exit_node() {
  // @@protoc_insertion_point(field_release:haoxing.route.FieldInfo.exit_node)
  
  ::haoxing::route::NodeXYZ* temp = _impl_.exit_node_;
  _impl_.exit_node_ = nullptr;
  return temp;
}
inline ::haoxing::route::NodeXYZ* FieldInfo::_internal_mutable_exit_node() {
  
  if (_impl_.exit_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::NodeXYZ>(GetArenaForAllocation());
    _impl_.exit_node_ = p;
  }
  return _impl_.exit_node_;
}
inline ::haoxing::route::NodeXYZ* FieldInfo::mutable_exit_node() {
  ::haoxing::route::NodeXYZ* _msg = _internal_mutable_exit_node();
  // @@protoc_insertion_point(field_mutable:haoxing.route.FieldInfo.exit_node)
  return _msg;
}
inline void FieldInfo::set_allocated_exit_node(::haoxing::route::NodeXYZ* exit_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exit_node_;
  }
  if (exit_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exit_node);
    if (message_arena != submessage_arena) {
      exit_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exit_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.exit_node_ = exit_node;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.FieldInfo.exit_node)
}

// repeated .haoxing.route.NodeXYZ fieldNodes = 3;
inline int FieldInfo::_internal_fieldnodes_size() const {
  return _impl_.fieldnodes_.size();
}
inline int FieldInfo::fieldnodes_size() const {
  return _internal_fieldnodes_size();
}
inline void FieldInfo::clear_fieldnodes() {
  _impl_.fieldnodes_.Clear();
}
inline ::haoxing::route::NodeXYZ* FieldInfo::mutable_fieldnodes(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.FieldInfo.fieldNodes)
  return _impl_.fieldnodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
FieldInfo::mutable_fieldnodes() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.FieldInfo.fieldNodes)
  return &_impl_.fieldnodes_;
}
inline const ::haoxing::route::NodeXYZ& FieldInfo::_internal_fieldnodes(int index) const {
  return _impl_.fieldnodes_.Get(index);
}
inline const ::haoxing::route::NodeXYZ& FieldInfo::fieldnodes(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.FieldInfo.fieldNodes)
  return _internal_fieldnodes(index);
}
inline ::haoxing::route::NodeXYZ* FieldInfo::_internal_add_fieldnodes() {
  return _impl_.fieldnodes_.Add();
}
inline ::haoxing::route::NodeXYZ* FieldInfo::add_fieldnodes() {
  ::haoxing::route::NodeXYZ* _add = _internal_add_fieldnodes();
  // @@protoc_insertion_point(field_add:haoxing.route.FieldInfo.fieldNodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
FieldInfo::fieldnodes() const {
  // @@protoc_insertion_point(field_list:haoxing.route.FieldInfo.fieldNodes)
  return _impl_.fieldnodes_;
}

// repeated .haoxing.route.Obstacle obstacles = 4;
inline int FieldInfo::_internal_obstacles_size() const {
  return _impl_.obstacles_.size();
}
inline int FieldInfo::obstacles_size() const {
  return _internal_obstacles_size();
}
inline void FieldInfo::clear_obstacles() {
  _impl_.obstacles_.Clear();
}
inline ::haoxing::route::Obstacle* FieldInfo::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.FieldInfo.obstacles)
  return _impl_.obstacles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::Obstacle >*
FieldInfo::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.FieldInfo.obstacles)
  return &_impl_.obstacles_;
}
inline const ::haoxing::route::Obstacle& FieldInfo::_internal_obstacles(int index) const {
  return _impl_.obstacles_.Get(index);
}
inline const ::haoxing::route::Obstacle& FieldInfo::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.FieldInfo.obstacles)
  return _internal_obstacles(index);
}
inline ::haoxing::route::Obstacle* FieldInfo::_internal_add_obstacles() {
  return _impl_.obstacles_.Add();
}
inline ::haoxing::route::Obstacle* FieldInfo::add_obstacles() {
  ::haoxing::route::Obstacle* _add = _internal_add_obstacles();
  // @@protoc_insertion_point(field_add:haoxing.route.FieldInfo.obstacles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::Obstacle >&
FieldInfo::obstacles() const {
  // @@protoc_insertion_point(field_list:haoxing.route.FieldInfo.obstacles)
  return _impl_.obstacles_;
}

// repeated double preset_spaces = 5;
inline int FieldInfo::_internal_preset_spaces_size() const {
  return _impl_.preset_spaces_.size();
}
inline int FieldInfo::preset_spaces_size() const {
  return _internal_preset_spaces_size();
}
inline void FieldInfo::clear_preset_spaces() {
  _impl_.preset_spaces_.Clear();
}
inline double FieldInfo::_internal_preset_spaces(int index) const {
  return _impl_.preset_spaces_.Get(index);
}
inline double FieldInfo::preset_spaces(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.FieldInfo.preset_spaces)
  return _internal_preset_spaces(index);
}
inline void FieldInfo::set_preset_spaces(int index, double value) {
  _impl_.preset_spaces_.Set(index, value);
  // @@protoc_insertion_point(field_set:haoxing.route.FieldInfo.preset_spaces)
}
inline void FieldInfo::_internal_add_preset_spaces(double value) {
  _impl_.preset_spaces_.Add(value);
}
inline void FieldInfo::add_preset_spaces(double value) {
  _internal_add_preset_spaces(value);
  // @@protoc_insertion_point(field_add:haoxing.route.FieldInfo.preset_spaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
FieldInfo::_internal_preset_spaces() const {
  return _impl_.preset_spaces_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
FieldInfo::preset_spaces() const {
  // @@protoc_insertion_point(field_list:haoxing.route.FieldInfo.preset_spaces)
  return _internal_preset_spaces();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
FieldInfo::_internal_mutable_preset_spaces() {
  return &_impl_.preset_spaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
FieldInfo::mutable_preset_spaces() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.FieldInfo.preset_spaces)
  return _internal_mutable_preset_spaces();
}

// -------------------------------------------------------------------

// PlanParam

// double inter_sp = 1;
inline void PlanParam::clear_inter_sp() {
  _impl_.inter_sp_ = 0;
}
inline double PlanParam::_internal_inter_sp() const {
  return _impl_.inter_sp_;
}
inline double PlanParam::inter_sp() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.inter_sp)
  return _internal_inter_sp();
}
inline void PlanParam::_internal_set_inter_sp(double value) {
  
  _impl_.inter_sp_ = value;
}
inline void PlanParam::set_inter_sp(double value) {
  _internal_set_inter_sp(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.inter_sp)
}

// double route_type = 2;
inline void PlanParam::clear_route_type() {
  _impl_.route_type_ = 0;
}
inline double PlanParam::_internal_route_type() const {
  return _impl_.route_type_;
}
inline double PlanParam::route_type() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.route_type)
  return _internal_route_type();
}
inline void PlanParam::_internal_set_route_type(double value) {
  
  _impl_.route_type_ = value;
}
inline void PlanParam::set_route_type(double value) {
  _internal_set_route_type(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.route_type)
}

// double task_type = 3;
inline void PlanParam::clear_task_type() {
  _impl_.task_type_ = 0;
}
inline double PlanParam::_internal_task_type() const {
  return _impl_.task_type_;
}
inline double PlanParam::task_type() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.task_type)
  return _internal_task_type();
}
inline void PlanParam::_internal_set_task_type(double value) {
  
  _impl_.task_type_ = value;
}
inline void PlanParam::set_task_type(double value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.task_type)
}

// bool modify_orientation = 4;
inline void PlanParam::clear_modify_orientation() {
  _impl_.modify_orientation_ = false;
}
inline bool PlanParam::_internal_modify_orientation() const {
  return _impl_.modify_orientation_;
}
inline bool PlanParam::modify_orientation() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.modify_orientation)
  return _internal_modify_orientation();
}
inline void PlanParam::_internal_set_modify_orientation(bool value) {
  
  _impl_.modify_orientation_ = value;
}
inline void PlanParam::set_modify_orientation(bool value) {
  _internal_set_modify_orientation(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.modify_orientation)
}

// bool acc_overlap = 5;
inline void PlanParam::clear_acc_overlap() {
  _impl_.acc_overlap_ = false;
}
inline bool PlanParam::_internal_acc_overlap() const {
  return _impl_.acc_overlap_;
}
inline bool PlanParam::acc_overlap() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.acc_overlap)
  return _internal_acc_overlap();
}
inline void PlanParam::_internal_set_acc_overlap(bool value) {
  
  _impl_.acc_overlap_ = value;
}
inline void PlanParam::set_acc_overlap(bool value) {
  _internal_set_acc_overlap(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.acc_overlap)
}

// bool multi_vehicle = 6;
inline void PlanParam::clear_multi_vehicle() {
  _impl_.multi_vehicle_ = false;
}
inline bool PlanParam::_internal_multi_vehicle() const {
  return _impl_.multi_vehicle_;
}
inline bool PlanParam::multi_vehicle() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.multi_vehicle)
  return _internal_multi_vehicle();
}
inline void PlanParam::_internal_set_multi_vehicle(bool value) {
  
  _impl_.multi_vehicle_ = value;
}
inline void PlanParam::set_multi_vehicle(bool value) {
  _internal_set_multi_vehicle(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.multi_vehicle)
}

// repeated int32 task_vehicle_num = 7;
inline int PlanParam::_internal_task_vehicle_num_size() const {
  return _impl_.task_vehicle_num_.size();
}
inline int PlanParam::task_vehicle_num_size() const {
  return _internal_task_vehicle_num_size();
}
inline void PlanParam::clear_task_vehicle_num() {
  _impl_.task_vehicle_num_.Clear();
}
inline int32_t PlanParam::_internal_task_vehicle_num(int index) const {
  return _impl_.task_vehicle_num_.Get(index);
}
inline int32_t PlanParam::task_vehicle_num(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.task_vehicle_num)
  return _internal_task_vehicle_num(index);
}
inline void PlanParam::set_task_vehicle_num(int index, int32_t value) {
  _impl_.task_vehicle_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.task_vehicle_num)
}
inline void PlanParam::_internal_add_task_vehicle_num(int32_t value) {
  _impl_.task_vehicle_num_.Add(value);
}
inline void PlanParam::add_task_vehicle_num(int32_t value) {
  _internal_add_task_vehicle_num(value);
  // @@protoc_insertion_point(field_add:haoxing.route.PlanParam.task_vehicle_num)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PlanParam::_internal_task_vehicle_num() const {
  return _impl_.task_vehicle_num_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PlanParam::task_vehicle_num() const {
  // @@protoc_insertion_point(field_list:haoxing.route.PlanParam.task_vehicle_num)
  return _internal_task_vehicle_num();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PlanParam::_internal_mutable_task_vehicle_num() {
  return &_impl_.task_vehicle_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PlanParam::mutable_task_vehicle_num() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.PlanParam.task_vehicle_num)
  return _internal_mutable_task_vehicle_num();
}

// repeated .haoxing.route.NodeXYZ service_nodes = 8;
inline int PlanParam::_internal_service_nodes_size() const {
  return _impl_.service_nodes_.size();
}
inline int PlanParam::service_nodes_size() const {
  return _internal_service_nodes_size();
}
inline void PlanParam::clear_service_nodes() {
  _impl_.service_nodes_.Clear();
}
inline ::haoxing::route::NodeXYZ* PlanParam::mutable_service_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.PlanParam.service_nodes)
  return _impl_.service_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
PlanParam::mutable_service_nodes() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.PlanParam.service_nodes)
  return &_impl_.service_nodes_;
}
inline const ::haoxing::route::NodeXYZ& PlanParam::_internal_service_nodes(int index) const {
  return _impl_.service_nodes_.Get(index);
}
inline const ::haoxing::route::NodeXYZ& PlanParam::service_nodes(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.service_nodes)
  return _internal_service_nodes(index);
}
inline ::haoxing::route::NodeXYZ* PlanParam::_internal_add_service_nodes() {
  return _impl_.service_nodes_.Add();
}
inline ::haoxing::route::NodeXYZ* PlanParam::add_service_nodes() {
  ::haoxing::route::NodeXYZ* _add = _internal_add_service_nodes();
  // @@protoc_insertion_point(field_add:haoxing.route.PlanParam.service_nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
PlanParam::service_nodes() const {
  // @@protoc_insertion_point(field_list:haoxing.route.PlanParam.service_nodes)
  return _impl_.service_nodes_;
}

// -------------------------------------------------------------------

// Vehicle

// double length = 1;
inline void Vehicle::clear_length() {
  _impl_.length_ = 0;
}
inline double Vehicle::_internal_length() const {
  return _impl_.length_;
}
inline double Vehicle::length() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.length)
  return _internal_length();
}
inline void Vehicle::_internal_set_length(double value) {
  
  _impl_.length_ = value;
}
inline void Vehicle::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.length)
}

// bool reverse = 2;
inline void Vehicle::clear_reverse() {
  _impl_.reverse_ = false;
}
inline bool Vehicle::_internal_reverse() const {
  return _impl_.reverse_;
}
inline bool Vehicle::reverse() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.reverse)
  return _internal_reverse();
}
inline void Vehicle::_internal_set_reverse(bool value) {
  
  _impl_.reverse_ = value;
}
inline void Vehicle::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.reverse)
}

// double over_all_width = 3;
inline void Vehicle::clear_over_all_width() {
  _impl_.over_all_width_ = 0;
}
inline double Vehicle::_internal_over_all_width() const {
  return _impl_.over_all_width_;
}
inline double Vehicle::over_all_width() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.over_all_width)
  return _internal_over_all_width();
}
inline void Vehicle::_internal_set_over_all_width(double value) {
  
  _impl_.over_all_width_ = value;
}
inline void Vehicle::set_over_all_width(double value) {
  _internal_set_over_all_width(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.over_all_width)
}

// double front_end_to_location = 4;
inline void Vehicle::clear_front_end_to_location() {
  _impl_.front_end_to_location_ = 0;
}
inline double Vehicle::_internal_front_end_to_location() const {
  return _impl_.front_end_to_location_;
}
inline double Vehicle::front_end_to_location() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.front_end_to_location)
  return _internal_front_end_to_location();
}
inline void Vehicle::_internal_set_front_end_to_location(double value) {
  
  _impl_.front_end_to_location_ = value;
}
inline void Vehicle::set_front_end_to_location(double value) {
  _internal_set_front_end_to_location(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.front_end_to_location)
}

// double rear_end_to_location = 5;
inline void Vehicle::clear_rear_end_to_location() {
  _impl_.rear_end_to_location_ = 0;
}
inline double Vehicle::_internal_rear_end_to_location() const {
  return _impl_.rear_end_to_location_;
}
inline double Vehicle::rear_end_to_location() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.rear_end_to_location)
  return _internal_rear_end_to_location();
}
inline void Vehicle::_internal_set_rear_end_to_location(double value) {
  
  _impl_.rear_end_to_location_ = value;
}
inline void Vehicle::set_rear_end_to_location(double value) {
  _internal_set_rear_end_to_location(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.rear_end_to_location)
}

// double wheel_base = 6;
inline void Vehicle::clear_wheel_base() {
  _impl_.wheel_base_ = 0;
}
inline double Vehicle::_internal_wheel_base() const {
  return _impl_.wheel_base_;
}
inline double Vehicle::wheel_base() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.wheel_base)
  return _internal_wheel_base();
}
inline void Vehicle::_internal_set_wheel_base(double value) {
  
  _impl_.wheel_base_ = value;
}
inline void Vehicle::set_wheel_base(double value) {
  _internal_set_wheel_base(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.wheel_base)
}

// double radius = 7;
inline void Vehicle::clear_radius() {
  _impl_.radius_ = 0;
}
inline double Vehicle::_internal_radius() const {
  return _impl_.radius_;
}
inline double Vehicle::radius() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.radius)
  return _internal_radius();
}
inline void Vehicle::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void Vehicle::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.radius)
}

// -------------------------------------------------------------------

// Implement

// double width = 1;
inline void Implement::clear_width() {
  _impl_.width_ = 0;
}
inline double Implement::_internal_width() const {
  return _impl_.width_;
}
inline double Implement::width() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Implement.width)
  return _internal_width();
}
inline void Implement::_internal_set_width(double value) {
  
  _impl_.width_ = value;
}
inline void Implement::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Implement.width)
}

// double length = 2;
inline void Implement::clear_length() {
  _impl_.length_ = 0;
}
inline double Implement::_internal_length() const {
  return _impl_.length_;
}
inline double Implement::length() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Implement.length)
  return _internal_length();
}
inline void Implement::_internal_set_length(double value) {
  
  _impl_.length_ = value;
}
inline void Implement::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Implement.length)
}

// double right_offset = 3;
inline void Implement::clear_right_offset() {
  _impl_.right_offset_ = 0;
}
inline double Implement::_internal_right_offset() const {
  return _impl_.right_offset_;
}
inline double Implement::right_offset() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Implement.right_offset)
  return _internal_right_offset();
}
inline void Implement::_internal_set_right_offset(double value) {
  
  _impl_.right_offset_ = value;
}
inline void Implement::set_right_offset(double value) {
  _internal_set_right_offset(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Implement.right_offset)
}

// double left_offset = 4;
inline void Implement::clear_left_offset() {
  _impl_.left_offset_ = 0;
}
inline double Implement::_internal_left_offset() const {
  return _impl_.left_offset_;
}
inline double Implement::left_offset() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Implement.left_offset)
  return _internal_left_offset();
}
inline void Implement::_internal_set_left_offset(double value) {
  
  _impl_.left_offset_ = value;
}
inline void Implement::set_left_offset(double value) {
  _internal_set_left_offset(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Implement.left_offset)
}

// int32 linkage_mode = 5;
inline void Implement::clear_linkage_mode() {
  _impl_.linkage_mode_ = 0;
}
inline int32_t Implement::_internal_linkage_mode() const {
  return _impl_.linkage_mode_;
}
inline int32_t Implement::linkage_mode() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Implement.linkage_mode)
  return _internal_linkage_mode();
}
inline void Implement::_internal_set_linkage_mode(int32_t value) {
  
  _impl_.linkage_mode_ = value;
}
inline void Implement::set_linkage_mode(int32_t value) {
  _internal_set_linkage_mode(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Implement.linkage_mode)
}

// -------------------------------------------------------------------

// Obstacle

// double x = 1;
inline void Obstacle::clear_x() {
  _impl_.x_ = 0;
}
inline double Obstacle::_internal_x() const {
  return _impl_.x_;
}
inline double Obstacle::x() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Obstacle.x)
  return _internal_x();
}
inline void Obstacle::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Obstacle::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Obstacle.x)
}

// double y = 2;
inline void Obstacle::clear_y() {
  _impl_.y_ = 0;
}
inline double Obstacle::_internal_y() const {
  return _impl_.y_;
}
inline double Obstacle::y() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Obstacle.y)
  return _internal_y();
}
inline void Obstacle::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Obstacle::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Obstacle.y)
}

// double z = 3;
inline void Obstacle::clear_z() {
  _impl_.z_ = 0;
}
inline double Obstacle::_internal_z() const {
  return _impl_.z_;
}
inline double Obstacle::z() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Obstacle.z)
  return _internal_z();
}
inline void Obstacle::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Obstacle::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Obstacle.z)
}

// double r = 4;
inline void Obstacle::clear_r() {
  _impl_.r_ = 0;
}
inline double Obstacle::_internal_r() const {
  return _impl_.r_;
}
inline double Obstacle::r() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Obstacle.r)
  return _internal_r();
}
inline void Obstacle::_internal_set_r(double value) {
  
  _impl_.r_ = value;
}
inline void Obstacle::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Obstacle.r)
}

// double r_w = 5;
inline void Obstacle::clear_r_w() {
  _impl_.r_w_ = 0;
}
inline double Obstacle::_internal_r_w() const {
  return _impl_.r_w_;
}
inline double Obstacle::r_w() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Obstacle.r_w)
  return _internal_r_w();
}
inline void Obstacle::_internal_set_r_w(double value) {
  
  _impl_.r_w_ = value;
}
inline void Obstacle::set_r_w(double value) {
  _internal_set_r_w(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Obstacle.r_w)
}

// -------------------------------------------------------------------

// RequestParam

// repeated .haoxing.route.FieldInfo field_infos = 1;
inline int RequestParam::_internal_field_infos_size() const {
  return _impl_.field_infos_.size();
}
inline int RequestParam::field_infos_size() const {
  return _internal_field_infos_size();
}
inline void RequestParam::clear_field_infos() {
  _impl_.field_infos_.Clear();
}
inline ::haoxing::route::FieldInfo* RequestParam::mutable_field_infos(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.RequestParam.field_infos)
  return _impl_.field_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::FieldInfo >*
RequestParam::mutable_field_infos() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.RequestParam.field_infos)
  return &_impl_.field_infos_;
}
inline const ::haoxing::route::FieldInfo& RequestParam::_internal_field_infos(int index) const {
  return _impl_.field_infos_.Get(index);
}
inline const ::haoxing::route::FieldInfo& RequestParam::field_infos(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.RequestParam.field_infos)
  return _internal_field_infos(index);
}
inline ::haoxing::route::FieldInfo* RequestParam::_internal_add_field_infos() {
  return _impl_.field_infos_.Add();
}
inline ::haoxing::route::FieldInfo* RequestParam::add_field_infos() {
  ::haoxing::route::FieldInfo* _add = _internal_add_field_infos();
  // @@protoc_insertion_point(field_add:haoxing.route.RequestParam.field_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::FieldInfo >&
RequestParam::field_infos() const {
  // @@protoc_insertion_point(field_list:haoxing.route.RequestParam.field_infos)
  return _impl_.field_infos_;
}

// .haoxing.route.PlanParam plan_param = 2;
inline bool RequestParam::_internal_has_plan_param() const {
  return this != internal_default_instance() && _impl_.plan_param_ != nullptr;
}
inline bool RequestParam::has_plan_param() const {
  return _internal_has_plan_param();
}
inline void RequestParam::clear_plan_param() {
  if (GetArenaForAllocation() == nullptr && _impl_.plan_param_ != nullptr) {
    delete _impl_.plan_param_;
  }
  _impl_.plan_param_ = nullptr;
}
inline const ::haoxing::route::PlanParam& RequestParam::_internal_plan_param() const {
  const ::haoxing::route::PlanParam* p = _impl_.plan_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::PlanParam&>(
      ::haoxing::route::_PlanParam_default_instance_);
}
inline const ::haoxing::route::PlanParam& RequestParam::plan_param() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RequestParam.plan_param)
  return _internal_plan_param();
}
inline void RequestParam::unsafe_arena_set_allocated_plan_param(
    ::haoxing::route::PlanParam* plan_param) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.plan_param_);
  }
  _impl_.plan_param_ = plan_param;
  if (plan_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.RequestParam.plan_param)
}
inline ::haoxing::route::PlanParam* RequestParam::release_plan_param() {
  
  ::haoxing::route::PlanParam* temp = _impl_.plan_param_;
  _impl_.plan_param_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::PlanParam* RequestParam::unsafe_arena_release_plan_param() {
  // @@protoc_insertion_point(field_release:haoxing.route.RequestParam.plan_param)
  
  ::haoxing::route::PlanParam* temp = _impl_.plan_param_;
  _impl_.plan_param_ = nullptr;
  return temp;
}
inline ::haoxing::route::PlanParam* RequestParam::_internal_mutable_plan_param() {
  
  if (_impl_.plan_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::PlanParam>(GetArenaForAllocation());
    _impl_.plan_param_ = p;
  }
  return _impl_.plan_param_;
}
inline ::haoxing::route::PlanParam* RequestParam::mutable_plan_param() {
  ::haoxing::route::PlanParam* _msg = _internal_mutable_plan_param();
  // @@protoc_insertion_point(field_mutable:haoxing.route.RequestParam.plan_param)
  return _msg;
}
inline void RequestParam::set_allocated_plan_param(::haoxing::route::PlanParam* plan_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.plan_param_;
  }
  if (plan_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(plan_param);
    if (message_arena != submessage_arena) {
      plan_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plan_param, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.plan_param_ = plan_param;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.RequestParam.plan_param)
}

// .haoxing.route.Vehicle vehicle = 3;
inline bool RequestParam::_internal_has_vehicle() const {
  return this != internal_default_instance() && _impl_.vehicle_ != nullptr;
}
inline bool RequestParam::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void RequestParam::clear_vehicle() {
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
}
inline const ::haoxing::route::Vehicle& RequestParam::_internal_vehicle() const {
  const ::haoxing::route::Vehicle* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::Vehicle&>(
      ::haoxing::route::_Vehicle_default_instance_);
}
inline const ::haoxing::route::Vehicle& RequestParam::vehicle() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RequestParam.vehicle)
  return _internal_vehicle();
}
inline void RequestParam::unsafe_arena_set_allocated_vehicle(
    ::haoxing::route::Vehicle* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.RequestParam.vehicle)
}
inline ::haoxing::route::Vehicle* RequestParam::release_vehicle() {
  
  ::haoxing::route::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::Vehicle* RequestParam::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:haoxing.route.RequestParam.vehicle)
  
  ::haoxing::route::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::haoxing::route::Vehicle* RequestParam::_internal_mutable_vehicle() {
  
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::Vehicle>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::haoxing::route::Vehicle* RequestParam::mutable_vehicle() {
  ::haoxing::route::Vehicle* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:haoxing.route.RequestParam.vehicle)
  return _msg;
}
inline void RequestParam::set_allocated_vehicle(::haoxing::route::Vehicle* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.RequestParam.vehicle)
}

// .haoxing.route.Implement implement = 4;
inline bool RequestParam::_internal_has_implement() const {
  return this != internal_default_instance() && _impl_.implement_ != nullptr;
}
inline bool RequestParam::has_implement() const {
  return _internal_has_implement();
}
inline void RequestParam::clear_implement() {
  if (GetArenaForAllocation() == nullptr && _impl_.implement_ != nullptr) {
    delete _impl_.implement_;
  }
  _impl_.implement_ = nullptr;
}
inline const ::haoxing::route::Implement& RequestParam::_internal_implement() const {
  const ::haoxing::route::Implement* p = _impl_.implement_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::Implement&>(
      ::haoxing::route::_Implement_default_instance_);
}
inline const ::haoxing::route::Implement& RequestParam::implement() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RequestParam.implement)
  return _internal_implement();
}
inline void RequestParam::unsafe_arena_set_allocated_implement(
    ::haoxing::route::Implement* implement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.implement_);
  }
  _impl_.implement_ = implement;
  if (implement) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.RequestParam.implement)
}
inline ::haoxing::route::Implement* RequestParam::release_implement() {
  
  ::haoxing::route::Implement* temp = _impl_.implement_;
  _impl_.implement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::Implement* RequestParam::unsafe_arena_release_implement() {
  // @@protoc_insertion_point(field_release:haoxing.route.RequestParam.implement)
  
  ::haoxing::route::Implement* temp = _impl_.implement_;
  _impl_.implement_ = nullptr;
  return temp;
}
inline ::haoxing::route::Implement* RequestParam::_internal_mutable_implement() {
  
  if (_impl_.implement_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::Implement>(GetArenaForAllocation());
    _impl_.implement_ = p;
  }
  return _impl_.implement_;
}
inline ::haoxing::route::Implement* RequestParam::mutable_implement() {
  ::haoxing::route::Implement* _msg = _internal_mutable_implement();
  // @@protoc_insertion_point(field_mutable:haoxing.route.RequestParam.implement)
  return _msg;
}
inline void RequestParam::set_allocated_implement(::haoxing::route::Implement* implement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.implement_;
  }
  if (implement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(implement);
    if (message_arena != submessage_arena) {
      implement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, implement, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.implement_ = implement;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.RequestParam.implement)
}

// -------------------------------------------------------------------

// ResponseParam

// repeated .haoxing.route.NodeXYZ nodes = 1;
inline int ResponseParam::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int ResponseParam::nodes_size() const {
  return _internal_nodes_size();
}
inline void ResponseParam::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::haoxing::route::NodeXYZ* ResponseParam::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.ResponseParam.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
ResponseParam::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.ResponseParam.nodes)
  return &_impl_.nodes_;
}
inline const ::haoxing::route::NodeXYZ& ResponseParam::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::haoxing::route::NodeXYZ& ResponseParam::nodes(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.ResponseParam.nodes)
  return _internal_nodes(index);
}
inline ::haoxing::route::NodeXYZ* ResponseParam::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::haoxing::route::NodeXYZ* ResponseParam::add_nodes() {
  ::haoxing::route::NodeXYZ* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:haoxing.route.ResponseParam.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
ResponseParam::nodes() const {
  // @@protoc_insertion_point(field_list:haoxing.route.ResponseParam.nodes)
  return _impl_.nodes_;
}

// double mileage = 2;
inline void ResponseParam::clear_mileage() {
  _impl_.mileage_ = 0;
}
inline double ResponseParam::_internal_mileage() const {
  return _impl_.mileage_;
}
inline double ResponseParam::mileage() const {
  // @@protoc_insertion_point(field_get:haoxing.route.ResponseParam.mileage)
  return _internal_mileage();
}
inline void ResponseParam::_internal_set_mileage(double value) {
  
  _impl_.mileage_ = value;
}
inline void ResponseParam::set_mileage(double value) {
  _internal_set_mileage(value);
  // @@protoc_insertion_point(field_set:haoxing.route.ResponseParam.mileage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace route
}  // namespace haoxing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_route_2eproto
