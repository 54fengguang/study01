// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_route_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_route_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_route_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_route_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_route_2eproto;
namespace haoxing {
namespace route {
class FarmTools;
struct FarmToolsDefaultTypeInternal;
extern FarmToolsDefaultTypeInternal _FarmTools_default_instance_;
class GisFieldInfo;
struct GisFieldInfoDefaultTypeInternal;
extern GisFieldInfoDefaultTypeInternal _GisFieldInfo_default_instance_;
class NodeXYZ;
struct NodeXYZDefaultTypeInternal;
extern NodeXYZDefaultTypeInternal _NodeXYZ_default_instance_;
class ObstacleReq;
struct ObstacleReqDefaultTypeInternal;
extern ObstacleReqDefaultTypeInternal _ObstacleReq_default_instance_;
class PlanParam;
struct PlanParamDefaultTypeInternal;
extern PlanParamDefaultTypeInternal _PlanParam_default_instance_;
class RoadPlanRequest;
struct RoadPlanRequestDefaultTypeInternal;
extern RoadPlanRequestDefaultTypeInternal _RoadPlanRequest_default_instance_;
class RoadPlanRespond;
struct RoadPlanRespondDefaultTypeInternal;
extern RoadPlanRespondDefaultTypeInternal _RoadPlanRespond_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace route
}  // namespace haoxing
PROTOBUF_NAMESPACE_OPEN
template<> ::haoxing::route::FarmTools* Arena::CreateMaybeMessage<::haoxing::route::FarmTools>(Arena*);
template<> ::haoxing::route::GisFieldInfo* Arena::CreateMaybeMessage<::haoxing::route::GisFieldInfo>(Arena*);
template<> ::haoxing::route::NodeXYZ* Arena::CreateMaybeMessage<::haoxing::route::NodeXYZ>(Arena*);
template<> ::haoxing::route::ObstacleReq* Arena::CreateMaybeMessage<::haoxing::route::ObstacleReq>(Arena*);
template<> ::haoxing::route::PlanParam* Arena::CreateMaybeMessage<::haoxing::route::PlanParam>(Arena*);
template<> ::haoxing::route::RoadPlanRequest* Arena::CreateMaybeMessage<::haoxing::route::RoadPlanRequest>(Arena*);
template<> ::haoxing::route::RoadPlanRespond* Arena::CreateMaybeMessage<::haoxing::route::RoadPlanRespond>(Arena*);
template<> ::haoxing::route::Vehicle* Arena::CreateMaybeMessage<::haoxing::route::Vehicle>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace haoxing {
namespace route {

// ===================================================================

class NodeXYZ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.NodeXYZ) */ {
 public:
  inline NodeXYZ() : NodeXYZ(nullptr) {}
  ~NodeXYZ() override;
  explicit PROTOBUF_CONSTEXPR NodeXYZ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeXYZ(const NodeXYZ& from);
  NodeXYZ(NodeXYZ&& from) noexcept
    : NodeXYZ() {
    *this = ::std::move(from);
  }

  inline NodeXYZ& operator=(const NodeXYZ& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeXYZ& operator=(NodeXYZ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeXYZ& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeXYZ* internal_default_instance() {
    return reinterpret_cast<const NodeXYZ*>(
               &_NodeXYZ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NodeXYZ& a, NodeXYZ& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeXYZ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeXYZ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeXYZ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeXYZ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeXYZ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeXYZ& from) {
    NodeXYZ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeXYZ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.NodeXYZ";
  }
  protected:
  explicit NodeXYZ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kYawFieldNumber = 4,
    kVFieldNumber = 5,
    kSFieldNumber = 6,
    kCurvatureFieldNumber = 7,
    kBackFieldNumber = 8,
    kStrCurFieldNumber = 9,
    kReverseFieldNumber = 10,
    kTypeFieldNumber = 11,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double yaw = 4;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // double v = 5;
  void clear_v();
  double v() const;
  void set_v(double value);
  private:
  double _internal_v() const;
  void _internal_set_v(double value);
  public:

  // double s = 6;
  void clear_s();
  double s() const;
  void set_s(double value);
  private:
  double _internal_s() const;
  void _internal_set_s(double value);
  public:

  // double curvature = 7;
  void clear_curvature();
  double curvature() const;
  void set_curvature(double value);
  private:
  double _internal_curvature() const;
  void _internal_set_curvature(double value);
  public:

  // int32 back = 8;
  void clear_back();
  int32_t back() const;
  void set_back(int32_t value);
  private:
  int32_t _internal_back() const;
  void _internal_set_back(int32_t value);
  public:

  // int32 str_cur = 9;
  void clear_str_cur();
  int32_t str_cur() const;
  void set_str_cur(int32_t value);
  private:
  int32_t _internal_str_cur() const;
  void _internal_set_str_cur(int32_t value);
  public:

  // bool reverse = 10;
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // int32 type = 11;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.NodeXYZ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    double yaw_;
    double v_;
    double s_;
    double curvature_;
    int32_t back_;
    int32_t str_cur_;
    bool reverse_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class GisFieldInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.GisFieldInfo) */ {
 public:
  inline GisFieldInfo() : GisFieldInfo(nullptr) {}
  ~GisFieldInfo() override;
  explicit PROTOBUF_CONSTEXPR GisFieldInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GisFieldInfo(const GisFieldInfo& from);
  GisFieldInfo(GisFieldInfo&& from) noexcept
    : GisFieldInfo() {
    *this = ::std::move(from);
  }

  inline GisFieldInfo& operator=(const GisFieldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GisFieldInfo& operator=(GisFieldInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GisFieldInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GisFieldInfo* internal_default_instance() {
    return reinterpret_cast<const GisFieldInfo*>(
               &_GisFieldInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GisFieldInfo& a, GisFieldInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GisFieldInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GisFieldInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GisFieldInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GisFieldInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GisFieldInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GisFieldInfo& from) {
    GisFieldInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GisFieldInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.GisFieldInfo";
  }
  protected:
  explicit GisFieldInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNodesFieldNumber = 3,
    kObstacleReqFieldNumber = 4,
    kPresetSpacesFieldNumber = 5,
    kEntranceNodeFieldNumber = 1,
    kExitNodeFieldNumber = 2,
  };
  // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
  int fieldnodes_size() const;
  private:
  int _internal_fieldnodes_size() const;
  public:
  void clear_fieldnodes();
  ::haoxing::route::NodeXYZ* mutable_fieldnodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
      mutable_fieldnodes();
  private:
  const ::haoxing::route::NodeXYZ& _internal_fieldnodes(int index) const;
  ::haoxing::route::NodeXYZ* _internal_add_fieldnodes();
  public:
  const ::haoxing::route::NodeXYZ& fieldnodes(int index) const;
  ::haoxing::route::NodeXYZ* add_fieldnodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
      fieldnodes() const;

  // repeated .haoxing.route.ObstacleReq obstacleReq = 4;
  int obstaclereq_size() const;
  private:
  int _internal_obstaclereq_size() const;
  public:
  void clear_obstaclereq();
  ::haoxing::route::ObstacleReq* mutable_obstaclereq(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::ObstacleReq >*
      mutable_obstaclereq();
  private:
  const ::haoxing::route::ObstacleReq& _internal_obstaclereq(int index) const;
  ::haoxing::route::ObstacleReq* _internal_add_obstaclereq();
  public:
  const ::haoxing::route::ObstacleReq& obstaclereq(int index) const;
  ::haoxing::route::ObstacleReq* add_obstaclereq();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::ObstacleReq >&
      obstaclereq() const;

  // repeated double preset_spaces = 5;
  int preset_spaces_size() const;
  private:
  int _internal_preset_spaces_size() const;
  public:
  void clear_preset_spaces();
  private:
  double _internal_preset_spaces(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_preset_spaces() const;
  void _internal_add_preset_spaces(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_preset_spaces();
  public:
  double preset_spaces(int index) const;
  void set_preset_spaces(int index, double value);
  void add_preset_spaces(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      preset_spaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_preset_spaces();

  // .haoxing.route.NodeXYZ entrance_node = 1;
  bool has_entrance_node() const;
  private:
  bool _internal_has_entrance_node() const;
  public:
  void clear_entrance_node();
  const ::haoxing::route::NodeXYZ& entrance_node() const;
  PROTOBUF_NODISCARD ::haoxing::route::NodeXYZ* release_entrance_node();
  ::haoxing::route::NodeXYZ* mutable_entrance_node();
  void set_allocated_entrance_node(::haoxing::route::NodeXYZ* entrance_node);
  private:
  const ::haoxing::route::NodeXYZ& _internal_entrance_node() const;
  ::haoxing::route::NodeXYZ* _internal_mutable_entrance_node();
  public:
  void unsafe_arena_set_allocated_entrance_node(
      ::haoxing::route::NodeXYZ* entrance_node);
  ::haoxing::route::NodeXYZ* unsafe_arena_release_entrance_node();

  // .haoxing.route.NodeXYZ exit_node = 2;
  bool has_exit_node() const;
  private:
  bool _internal_has_exit_node() const;
  public:
  void clear_exit_node();
  const ::haoxing::route::NodeXYZ& exit_node() const;
  PROTOBUF_NODISCARD ::haoxing::route::NodeXYZ* release_exit_node();
  ::haoxing::route::NodeXYZ* mutable_exit_node();
  void set_allocated_exit_node(::haoxing::route::NodeXYZ* exit_node);
  private:
  const ::haoxing::route::NodeXYZ& _internal_exit_node() const;
  ::haoxing::route::NodeXYZ* _internal_mutable_exit_node();
  public:
  void unsafe_arena_set_allocated_exit_node(
      ::haoxing::route::NodeXYZ* exit_node);
  ::haoxing::route::NodeXYZ* unsafe_arena_release_exit_node();

  // @@protoc_insertion_point(class_scope:haoxing.route.GisFieldInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ > fieldnodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::ObstacleReq > obstaclereq_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > preset_spaces_;
    ::haoxing::route::NodeXYZ* entrance_node_;
    ::haoxing::route::NodeXYZ* exit_node_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class FarmTools final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.FarmTools) */ {
 public:
  inline FarmTools() : FarmTools(nullptr) {}
  ~FarmTools() override;
  explicit PROTOBUF_CONSTEXPR FarmTools(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmTools(const FarmTools& from);
  FarmTools(FarmTools&& from) noexcept
    : FarmTools() {
    *this = ::std::move(from);
  }

  inline FarmTools& operator=(const FarmTools& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmTools& operator=(FarmTools&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmTools& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmTools* internal_default_instance() {
    return reinterpret_cast<const FarmTools*>(
               &_FarmTools_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FarmTools& a, FarmTools& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmTools* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmTools* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmTools* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmTools>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmTools& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmTools& from) {
    FarmTools::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmTools* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.FarmTools";
  }
  protected:
  explicit FarmTools(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kLengthFieldNumber = 2,
    kLeftOffsetFieldNumber = 3,
    kRightOffsetFieldNumber = 4,
  };
  // double width = 1;
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // double length = 2;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // double leftOffset = 3;
  void clear_leftoffset();
  double leftoffset() const;
  void set_leftoffset(double value);
  private:
  double _internal_leftoffset() const;
  void _internal_set_leftoffset(double value);
  public:

  // double rightOffset = 4;
  void clear_rightoffset();
  double rightoffset() const;
  void set_rightoffset(double value);
  private:
  double _internal_rightoffset() const;
  void _internal_set_rightoffset(double value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.FarmTools)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double width_;
    double length_;
    double leftoffset_;
    double rightoffset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class Vehicle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  explicit PROTOBUF_CONSTEXPR Vehicle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.Vehicle";
  }
  protected:
  explicit Vehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kOverAllWidthFieldNumber = 3,
    kFrontEndToLocationFieldNumber = 4,
    kRearEndToLocationFieldNumber = 5,
    kWheelBaseFieldNumber = 6,
    kRadiusFieldNumber = 7,
    kReverseFieldNumber = 2,
  };
  // double length = 1;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // double over_all_width = 3;
  void clear_over_all_width();
  double over_all_width() const;
  void set_over_all_width(double value);
  private:
  double _internal_over_all_width() const;
  void _internal_set_over_all_width(double value);
  public:

  // double front_end_to_location = 4;
  void clear_front_end_to_location();
  double front_end_to_location() const;
  void set_front_end_to_location(double value);
  private:
  double _internal_front_end_to_location() const;
  void _internal_set_front_end_to_location(double value);
  public:

  // double rear_end_to_location = 5;
  void clear_rear_end_to_location();
  double rear_end_to_location() const;
  void set_rear_end_to_location(double value);
  private:
  double _internal_rear_end_to_location() const;
  void _internal_set_rear_end_to_location(double value);
  public:

  // double wheel_base = 6;
  void clear_wheel_base();
  double wheel_base() const;
  void set_wheel_base(double value);
  private:
  double _internal_wheel_base() const;
  void _internal_set_wheel_base(double value);
  public:

  // double radius = 7;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // bool reverse = 2;
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.Vehicle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double length_;
    double over_all_width_;
    double front_end_to_location_;
    double rear_end_to_location_;
    double wheel_base_;
    double radius_;
    bool reverse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class ObstacleReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.ObstacleReq) */ {
 public:
  inline ObstacleReq() : ObstacleReq(nullptr) {}
  ~ObstacleReq() override;
  explicit PROTOBUF_CONSTEXPR ObstacleReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleReq(const ObstacleReq& from);
  ObstacleReq(ObstacleReq&& from) noexcept
    : ObstacleReq() {
    *this = ::std::move(from);
  }

  inline ObstacleReq& operator=(const ObstacleReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleReq& operator=(ObstacleReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleReq* internal_default_instance() {
    return reinterpret_cast<const ObstacleReq*>(
               &_ObstacleReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ObstacleReq& a, ObstacleReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObstacleReq& from) {
    ObstacleReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.ObstacleReq";
  }
  protected:
  explicit ObstacleReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kRFieldNumber = 4,
    kRWFieldNumber = 5,
    kTaskIndexFieldNumber = 6,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double r = 4;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double r_w = 5;
  void clear_r_w();
  double r_w() const;
  void set_r_w(double value);
  private:
  double _internal_r_w() const;
  void _internal_set_r_w(double value);
  public:

  // int32 taskIndex = 6;
  void clear_taskindex();
  int32_t taskindex() const;
  void set_taskindex(int32_t value);
  private:
  int32_t _internal_taskindex() const;
  void _internal_set_taskindex(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.ObstacleReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    double r_;
    double r_w_;
    int32_t taskindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class PlanParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.PlanParam) */ {
 public:
  inline PlanParam() : PlanParam(nullptr) {}
  ~PlanParam() override;
  explicit PROTOBUF_CONSTEXPR PlanParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanParam(const PlanParam& from);
  PlanParam(PlanParam&& from) noexcept
    : PlanParam() {
    *this = ::std::move(from);
  }

  inline PlanParam& operator=(const PlanParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanParam& operator=(PlanParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanParam* internal_default_instance() {
    return reinterpret_cast<const PlanParam*>(
               &_PlanParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlanParam& a, PlanParam& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanParam& from) {
    PlanParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.PlanParam";
  }
  protected:
  explicit PlanParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNodesFieldNumber = 10,
    kLineSpaceFieldNumber = 1,
    kInterspaceFieldNumber = 2,
    kSafeDistanceFieldNumber = 3,
    kTurnRoundTypeFieldNumber = 4,
    kTaskTypeFieldNumber = 5,
    kTypeSeedingFieldNumber = 6,
    kModifyOrientationFieldNumber = 7,
    kAccOverlapFieldNumber = 8,
    kMultiVehicleFieldNumber = 9,
  };
  // repeated .haoxing.route.NodeXYZ service_nodes = 10;
  int service_nodes_size() const;
  private:
  int _internal_service_nodes_size() const;
  public:
  void clear_service_nodes();
  ::haoxing::route::NodeXYZ* mutable_service_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
      mutable_service_nodes();
  private:
  const ::haoxing::route::NodeXYZ& _internal_service_nodes(int index) const;
  ::haoxing::route::NodeXYZ* _internal_add_service_nodes();
  public:
  const ::haoxing::route::NodeXYZ& service_nodes(int index) const;
  ::haoxing::route::NodeXYZ* add_service_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
      service_nodes() const;

  // double lineSpace = 1;
  void clear_linespace();
  double linespace() const;
  void set_linespace(double value);
  private:
  double _internal_linespace() const;
  void _internal_set_linespace(double value);
  public:

  // double interspace = 2;
  void clear_interspace();
  double interspace() const;
  void set_interspace(double value);
  private:
  double _internal_interspace() const;
  void _internal_set_interspace(double value);
  public:

  // double safe_distance = 3;
  void clear_safe_distance();
  double safe_distance() const;
  void set_safe_distance(double value);
  private:
  double _internal_safe_distance() const;
  void _internal_set_safe_distance(double value);
  public:

  // double turn_round_type = 4;
  void clear_turn_round_type();
  double turn_round_type() const;
  void set_turn_round_type(double value);
  private:
  double _internal_turn_round_type() const;
  void _internal_set_turn_round_type(double value);
  public:

  // double task_type = 5;
  void clear_task_type();
  double task_type() const;
  void set_task_type(double value);
  private:
  double _internal_task_type() const;
  void _internal_set_task_type(double value);
  public:

  // double type_seeding = 6;
  void clear_type_seeding();
  double type_seeding() const;
  void set_type_seeding(double value);
  private:
  double _internal_type_seeding() const;
  void _internal_set_type_seeding(double value);
  public:

  // bool modify_orientation = 7;
  void clear_modify_orientation();
  bool modify_orientation() const;
  void set_modify_orientation(bool value);
  private:
  bool _internal_modify_orientation() const;
  void _internal_set_modify_orientation(bool value);
  public:

  // bool acc_overlap = 8;
  void clear_acc_overlap();
  bool acc_overlap() const;
  void set_acc_overlap(bool value);
  private:
  bool _internal_acc_overlap() const;
  void _internal_set_acc_overlap(bool value);
  public:

  // bool multi_vehicle = 9;
  void clear_multi_vehicle();
  bool multi_vehicle() const;
  void set_multi_vehicle(bool value);
  private:
  bool _internal_multi_vehicle() const;
  void _internal_set_multi_vehicle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.PlanParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ > service_nodes_;
    double linespace_;
    double interspace_;
    double safe_distance_;
    double turn_round_type_;
    double task_type_;
    double type_seeding_;
    bool modify_orientation_;
    bool acc_overlap_;
    bool multi_vehicle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RoadPlanRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.RoadPlanRequest) */ {
 public:
  inline RoadPlanRequest() : RoadPlanRequest(nullptr) {}
  ~RoadPlanRequest() override;
  explicit PROTOBUF_CONSTEXPR RoadPlanRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoadPlanRequest(const RoadPlanRequest& from);
  RoadPlanRequest(RoadPlanRequest&& from) noexcept
    : RoadPlanRequest() {
    *this = ::std::move(from);
  }

  inline RoadPlanRequest& operator=(const RoadPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadPlanRequest& operator=(RoadPlanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadPlanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadPlanRequest* internal_default_instance() {
    return reinterpret_cast<const RoadPlanRequest*>(
               &_RoadPlanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RoadPlanRequest& a, RoadPlanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadPlanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadPlanRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadPlanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadPlanRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoadPlanRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoadPlanRequest& from) {
    RoadPlanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadPlanRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.RoadPlanRequest";
  }
  protected:
  explicit RoadPlanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGisFieldInfoFieldNumber = 1,
    kFarmToolsFieldNumber = 2,
    kVehicleFieldNumber = 3,
    kPlanParamFieldNumber = 4,
  };
  // .haoxing.route.GisFieldInfo gisFieldInfo = 1;
  bool has_gisfieldinfo() const;
  private:
  bool _internal_has_gisfieldinfo() const;
  public:
  void clear_gisfieldinfo();
  const ::haoxing::route::GisFieldInfo& gisfieldinfo() const;
  PROTOBUF_NODISCARD ::haoxing::route::GisFieldInfo* release_gisfieldinfo();
  ::haoxing::route::GisFieldInfo* mutable_gisfieldinfo();
  void set_allocated_gisfieldinfo(::haoxing::route::GisFieldInfo* gisfieldinfo);
  private:
  const ::haoxing::route::GisFieldInfo& _internal_gisfieldinfo() const;
  ::haoxing::route::GisFieldInfo* _internal_mutable_gisfieldinfo();
  public:
  void unsafe_arena_set_allocated_gisfieldinfo(
      ::haoxing::route::GisFieldInfo* gisfieldinfo);
  ::haoxing::route::GisFieldInfo* unsafe_arena_release_gisfieldinfo();

  // .haoxing.route.FarmTools farmTools = 2;
  bool has_farmtools() const;
  private:
  bool _internal_has_farmtools() const;
  public:
  void clear_farmtools();
  const ::haoxing::route::FarmTools& farmtools() const;
  PROTOBUF_NODISCARD ::haoxing::route::FarmTools* release_farmtools();
  ::haoxing::route::FarmTools* mutable_farmtools();
  void set_allocated_farmtools(::haoxing::route::FarmTools* farmtools);
  private:
  const ::haoxing::route::FarmTools& _internal_farmtools() const;
  ::haoxing::route::FarmTools* _internal_mutable_farmtools();
  public:
  void unsafe_arena_set_allocated_farmtools(
      ::haoxing::route::FarmTools* farmtools);
  ::haoxing::route::FarmTools* unsafe_arena_release_farmtools();

  // .haoxing.route.Vehicle vehicle = 3;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::haoxing::route::Vehicle& vehicle() const;
  PROTOBUF_NODISCARD ::haoxing::route::Vehicle* release_vehicle();
  ::haoxing::route::Vehicle* mutable_vehicle();
  void set_allocated_vehicle(::haoxing::route::Vehicle* vehicle);
  private:
  const ::haoxing::route::Vehicle& _internal_vehicle() const;
  ::haoxing::route::Vehicle* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::haoxing::route::Vehicle* vehicle);
  ::haoxing::route::Vehicle* unsafe_arena_release_vehicle();

  // .haoxing.route.PlanParam planParam = 4;
  bool has_planparam() const;
  private:
  bool _internal_has_planparam() const;
  public:
  void clear_planparam();
  const ::haoxing::route::PlanParam& planparam() const;
  PROTOBUF_NODISCARD ::haoxing::route::PlanParam* release_planparam();
  ::haoxing::route::PlanParam* mutable_planparam();
  void set_allocated_planparam(::haoxing::route::PlanParam* planparam);
  private:
  const ::haoxing::route::PlanParam& _internal_planparam() const;
  ::haoxing::route::PlanParam* _internal_mutable_planparam();
  public:
  void unsafe_arena_set_allocated_planparam(
      ::haoxing::route::PlanParam* planparam);
  ::haoxing::route::PlanParam* unsafe_arena_release_planparam();

  // @@protoc_insertion_point(class_scope:haoxing.route.RoadPlanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::haoxing::route::GisFieldInfo* gisfieldinfo_;
    ::haoxing::route::FarmTools* farmtools_;
    ::haoxing::route::Vehicle* vehicle_;
    ::haoxing::route::PlanParam* planparam_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RoadPlanRespond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:haoxing.route.RoadPlanRespond) */ {
 public:
  inline RoadPlanRespond() : RoadPlanRespond(nullptr) {}
  ~RoadPlanRespond() override;
  explicit PROTOBUF_CONSTEXPR RoadPlanRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoadPlanRespond(const RoadPlanRespond& from);
  RoadPlanRespond(RoadPlanRespond&& from) noexcept
    : RoadPlanRespond() {
    *this = ::std::move(from);
  }

  inline RoadPlanRespond& operator=(const RoadPlanRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadPlanRespond& operator=(RoadPlanRespond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadPlanRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadPlanRespond* internal_default_instance() {
    return reinterpret_cast<const RoadPlanRespond*>(
               &_RoadPlanRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoadPlanRespond& a, RoadPlanRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadPlanRespond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadPlanRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadPlanRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadPlanRespond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoadPlanRespond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoadPlanRespond& from) {
    RoadPlanRespond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadPlanRespond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "haoxing.route.RoadPlanRespond";
  }
  protected:
  explicit RoadPlanRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kMileageFieldNumber = 2,
  };
  // repeated .haoxing.route.NodeXYZ nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::haoxing::route::NodeXYZ* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
      mutable_nodes();
  private:
  const ::haoxing::route::NodeXYZ& _internal_nodes(int index) const;
  ::haoxing::route::NodeXYZ* _internal_add_nodes();
  public:
  const ::haoxing::route::NodeXYZ& nodes(int index) const;
  ::haoxing::route::NodeXYZ* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
      nodes() const;

  // double mileage = 2;
  void clear_mileage();
  double mileage() const;
  void set_mileage(double value);
  private:
  double _internal_mileage() const;
  void _internal_set_mileage(double value);
  public:

  // @@protoc_insertion_point(class_scope:haoxing.route.RoadPlanRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ > nodes_;
    double mileage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_route_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NodeXYZ

// double x = 1;
inline void NodeXYZ::clear_x() {
  _impl_.x_ = 0;
}
inline double NodeXYZ::_internal_x() const {
  return _impl_.x_;
}
inline double NodeXYZ::x() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.x)
  return _internal_x();
}
inline void NodeXYZ::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void NodeXYZ::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.x)
}

// double y = 2;
inline void NodeXYZ::clear_y() {
  _impl_.y_ = 0;
}
inline double NodeXYZ::_internal_y() const {
  return _impl_.y_;
}
inline double NodeXYZ::y() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.y)
  return _internal_y();
}
inline void NodeXYZ::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void NodeXYZ::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.y)
}

// double z = 3;
inline void NodeXYZ::clear_z() {
  _impl_.z_ = 0;
}
inline double NodeXYZ::_internal_z() const {
  return _impl_.z_;
}
inline double NodeXYZ::z() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.z)
  return _internal_z();
}
inline void NodeXYZ::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void NodeXYZ::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.z)
}

// double yaw = 4;
inline void NodeXYZ::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline double NodeXYZ::_internal_yaw() const {
  return _impl_.yaw_;
}
inline double NodeXYZ::yaw() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.yaw)
  return _internal_yaw();
}
inline void NodeXYZ::_internal_set_yaw(double value) {
  
  _impl_.yaw_ = value;
}
inline void NodeXYZ::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.yaw)
}

// double v = 5;
inline void NodeXYZ::clear_v() {
  _impl_.v_ = 0;
}
inline double NodeXYZ::_internal_v() const {
  return _impl_.v_;
}
inline double NodeXYZ::v() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.v)
  return _internal_v();
}
inline void NodeXYZ::_internal_set_v(double value) {
  
  _impl_.v_ = value;
}
inline void NodeXYZ::set_v(double value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.v)
}

// double s = 6;
inline void NodeXYZ::clear_s() {
  _impl_.s_ = 0;
}
inline double NodeXYZ::_internal_s() const {
  return _impl_.s_;
}
inline double NodeXYZ::s() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.s)
  return _internal_s();
}
inline void NodeXYZ::_internal_set_s(double value) {
  
  _impl_.s_ = value;
}
inline void NodeXYZ::set_s(double value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.s)
}

// double curvature = 7;
inline void NodeXYZ::clear_curvature() {
  _impl_.curvature_ = 0;
}
inline double NodeXYZ::_internal_curvature() const {
  return _impl_.curvature_;
}
inline double NodeXYZ::curvature() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.curvature)
  return _internal_curvature();
}
inline void NodeXYZ::_internal_set_curvature(double value) {
  
  _impl_.curvature_ = value;
}
inline void NodeXYZ::set_curvature(double value) {
  _internal_set_curvature(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.curvature)
}

// int32 back = 8;
inline void NodeXYZ::clear_back() {
  _impl_.back_ = 0;
}
inline int32_t NodeXYZ::_internal_back() const {
  return _impl_.back_;
}
inline int32_t NodeXYZ::back() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.back)
  return _internal_back();
}
inline void NodeXYZ::_internal_set_back(int32_t value) {
  
  _impl_.back_ = value;
}
inline void NodeXYZ::set_back(int32_t value) {
  _internal_set_back(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.back)
}

// int32 str_cur = 9;
inline void NodeXYZ::clear_str_cur() {
  _impl_.str_cur_ = 0;
}
inline int32_t NodeXYZ::_internal_str_cur() const {
  return _impl_.str_cur_;
}
inline int32_t NodeXYZ::str_cur() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.str_cur)
  return _internal_str_cur();
}
inline void NodeXYZ::_internal_set_str_cur(int32_t value) {
  
  _impl_.str_cur_ = value;
}
inline void NodeXYZ::set_str_cur(int32_t value) {
  _internal_set_str_cur(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.str_cur)
}

// bool reverse = 10;
inline void NodeXYZ::clear_reverse() {
  _impl_.reverse_ = false;
}
inline bool NodeXYZ::_internal_reverse() const {
  return _impl_.reverse_;
}
inline bool NodeXYZ::reverse() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.reverse)
  return _internal_reverse();
}
inline void NodeXYZ::_internal_set_reverse(bool value) {
  
  _impl_.reverse_ = value;
}
inline void NodeXYZ::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.reverse)
}

// int32 type = 11;
inline void NodeXYZ::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t NodeXYZ::_internal_type() const {
  return _impl_.type_;
}
inline int32_t NodeXYZ::type() const {
  // @@protoc_insertion_point(field_get:haoxing.route.NodeXYZ.type)
  return _internal_type();
}
inline void NodeXYZ::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void NodeXYZ::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:haoxing.route.NodeXYZ.type)
}

// -------------------------------------------------------------------

// GisFieldInfo

// .haoxing.route.NodeXYZ entrance_node = 1;
inline bool GisFieldInfo::_internal_has_entrance_node() const {
  return this != internal_default_instance() && _impl_.entrance_node_ != nullptr;
}
inline bool GisFieldInfo::has_entrance_node() const {
  return _internal_has_entrance_node();
}
inline void GisFieldInfo::clear_entrance_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.entrance_node_ != nullptr) {
    delete _impl_.entrance_node_;
  }
  _impl_.entrance_node_ = nullptr;
}
inline const ::haoxing::route::NodeXYZ& GisFieldInfo::_internal_entrance_node() const {
  const ::haoxing::route::NodeXYZ* p = _impl_.entrance_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::NodeXYZ&>(
      ::haoxing::route::_NodeXYZ_default_instance_);
}
inline const ::haoxing::route::NodeXYZ& GisFieldInfo::entrance_node() const {
  // @@protoc_insertion_point(field_get:haoxing.route.GisFieldInfo.entrance_node)
  return _internal_entrance_node();
}
inline void GisFieldInfo::unsafe_arena_set_allocated_entrance_node(
    ::haoxing::route::NodeXYZ* entrance_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entrance_node_);
  }
  _impl_.entrance_node_ = entrance_node;
  if (entrance_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.GisFieldInfo.entrance_node)
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::release_entrance_node() {
  
  ::haoxing::route::NodeXYZ* temp = _impl_.entrance_node_;
  _impl_.entrance_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::unsafe_arena_release_entrance_node() {
  // @@protoc_insertion_point(field_release:haoxing.route.GisFieldInfo.entrance_node)
  
  ::haoxing::route::NodeXYZ* temp = _impl_.entrance_node_;
  _impl_.entrance_node_ = nullptr;
  return temp;
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::_internal_mutable_entrance_node() {
  
  if (_impl_.entrance_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::NodeXYZ>(GetArenaForAllocation());
    _impl_.entrance_node_ = p;
  }
  return _impl_.entrance_node_;
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::mutable_entrance_node() {
  ::haoxing::route::NodeXYZ* _msg = _internal_mutable_entrance_node();
  // @@protoc_insertion_point(field_mutable:haoxing.route.GisFieldInfo.entrance_node)
  return _msg;
}
inline void GisFieldInfo::set_allocated_entrance_node(::haoxing::route::NodeXYZ* entrance_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.entrance_node_;
  }
  if (entrance_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entrance_node);
    if (message_arena != submessage_arena) {
      entrance_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entrance_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.entrance_node_ = entrance_node;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.GisFieldInfo.entrance_node)
}

// .haoxing.route.NodeXYZ exit_node = 2;
inline bool GisFieldInfo::_internal_has_exit_node() const {
  return this != internal_default_instance() && _impl_.exit_node_ != nullptr;
}
inline bool GisFieldInfo::has_exit_node() const {
  return _internal_has_exit_node();
}
inline void GisFieldInfo::clear_exit_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.exit_node_ != nullptr) {
    delete _impl_.exit_node_;
  }
  _impl_.exit_node_ = nullptr;
}
inline const ::haoxing::route::NodeXYZ& GisFieldInfo::_internal_exit_node() const {
  const ::haoxing::route::NodeXYZ* p = _impl_.exit_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::NodeXYZ&>(
      ::haoxing::route::_NodeXYZ_default_instance_);
}
inline const ::haoxing::route::NodeXYZ& GisFieldInfo::exit_node() const {
  // @@protoc_insertion_point(field_get:haoxing.route.GisFieldInfo.exit_node)
  return _internal_exit_node();
}
inline void GisFieldInfo::unsafe_arena_set_allocated_exit_node(
    ::haoxing::route::NodeXYZ* exit_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exit_node_);
  }
  _impl_.exit_node_ = exit_node;
  if (exit_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.GisFieldInfo.exit_node)
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::release_exit_node() {
  
  ::haoxing::route::NodeXYZ* temp = _impl_.exit_node_;
  _impl_.exit_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::unsafe_arena_release_exit_node() {
  // @@protoc_insertion_point(field_release:haoxing.route.GisFieldInfo.exit_node)
  
  ::haoxing::route::NodeXYZ* temp = _impl_.exit_node_;
  _impl_.exit_node_ = nullptr;
  return temp;
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::_internal_mutable_exit_node() {
  
  if (_impl_.exit_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::NodeXYZ>(GetArenaForAllocation());
    _impl_.exit_node_ = p;
  }
  return _impl_.exit_node_;
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::mutable_exit_node() {
  ::haoxing::route::NodeXYZ* _msg = _internal_mutable_exit_node();
  // @@protoc_insertion_point(field_mutable:haoxing.route.GisFieldInfo.exit_node)
  return _msg;
}
inline void GisFieldInfo::set_allocated_exit_node(::haoxing::route::NodeXYZ* exit_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exit_node_;
  }
  if (exit_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exit_node);
    if (message_arena != submessage_arena) {
      exit_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exit_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.exit_node_ = exit_node;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.GisFieldInfo.exit_node)
}

// repeated .haoxing.route.NodeXYZ fieldNodes = 3;
inline int GisFieldInfo::_internal_fieldnodes_size() const {
  return _impl_.fieldnodes_.size();
}
inline int GisFieldInfo::fieldnodes_size() const {
  return _internal_fieldnodes_size();
}
inline void GisFieldInfo::clear_fieldnodes() {
  _impl_.fieldnodes_.Clear();
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::mutable_fieldnodes(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.GisFieldInfo.fieldNodes)
  return _impl_.fieldnodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
GisFieldInfo::mutable_fieldnodes() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.GisFieldInfo.fieldNodes)
  return &_impl_.fieldnodes_;
}
inline const ::haoxing::route::NodeXYZ& GisFieldInfo::_internal_fieldnodes(int index) const {
  return _impl_.fieldnodes_.Get(index);
}
inline const ::haoxing::route::NodeXYZ& GisFieldInfo::fieldnodes(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.GisFieldInfo.fieldNodes)
  return _internal_fieldnodes(index);
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::_internal_add_fieldnodes() {
  return _impl_.fieldnodes_.Add();
}
inline ::haoxing::route::NodeXYZ* GisFieldInfo::add_fieldnodes() {
  ::haoxing::route::NodeXYZ* _add = _internal_add_fieldnodes();
  // @@protoc_insertion_point(field_add:haoxing.route.GisFieldInfo.fieldNodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
GisFieldInfo::fieldnodes() const {
  // @@protoc_insertion_point(field_list:haoxing.route.GisFieldInfo.fieldNodes)
  return _impl_.fieldnodes_;
}

// repeated .haoxing.route.ObstacleReq obstacleReq = 4;
inline int GisFieldInfo::_internal_obstaclereq_size() const {
  return _impl_.obstaclereq_.size();
}
inline int GisFieldInfo::obstaclereq_size() const {
  return _internal_obstaclereq_size();
}
inline void GisFieldInfo::clear_obstaclereq() {
  _impl_.obstaclereq_.Clear();
}
inline ::haoxing::route::ObstacleReq* GisFieldInfo::mutable_obstaclereq(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.GisFieldInfo.obstacleReq)
  return _impl_.obstaclereq_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::ObstacleReq >*
GisFieldInfo::mutable_obstaclereq() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.GisFieldInfo.obstacleReq)
  return &_impl_.obstaclereq_;
}
inline const ::haoxing::route::ObstacleReq& GisFieldInfo::_internal_obstaclereq(int index) const {
  return _impl_.obstaclereq_.Get(index);
}
inline const ::haoxing::route::ObstacleReq& GisFieldInfo::obstaclereq(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.GisFieldInfo.obstacleReq)
  return _internal_obstaclereq(index);
}
inline ::haoxing::route::ObstacleReq* GisFieldInfo::_internal_add_obstaclereq() {
  return _impl_.obstaclereq_.Add();
}
inline ::haoxing::route::ObstacleReq* GisFieldInfo::add_obstaclereq() {
  ::haoxing::route::ObstacleReq* _add = _internal_add_obstaclereq();
  // @@protoc_insertion_point(field_add:haoxing.route.GisFieldInfo.obstacleReq)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::ObstacleReq >&
GisFieldInfo::obstaclereq() const {
  // @@protoc_insertion_point(field_list:haoxing.route.GisFieldInfo.obstacleReq)
  return _impl_.obstaclereq_;
}

// repeated double preset_spaces = 5;
inline int GisFieldInfo::_internal_preset_spaces_size() const {
  return _impl_.preset_spaces_.size();
}
inline int GisFieldInfo::preset_spaces_size() const {
  return _internal_preset_spaces_size();
}
inline void GisFieldInfo::clear_preset_spaces() {
  _impl_.preset_spaces_.Clear();
}
inline double GisFieldInfo::_internal_preset_spaces(int index) const {
  return _impl_.preset_spaces_.Get(index);
}
inline double GisFieldInfo::preset_spaces(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.GisFieldInfo.preset_spaces)
  return _internal_preset_spaces(index);
}
inline void GisFieldInfo::set_preset_spaces(int index, double value) {
  _impl_.preset_spaces_.Set(index, value);
  // @@protoc_insertion_point(field_set:haoxing.route.GisFieldInfo.preset_spaces)
}
inline void GisFieldInfo::_internal_add_preset_spaces(double value) {
  _impl_.preset_spaces_.Add(value);
}
inline void GisFieldInfo::add_preset_spaces(double value) {
  _internal_add_preset_spaces(value);
  // @@protoc_insertion_point(field_add:haoxing.route.GisFieldInfo.preset_spaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GisFieldInfo::_internal_preset_spaces() const {
  return _impl_.preset_spaces_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GisFieldInfo::preset_spaces() const {
  // @@protoc_insertion_point(field_list:haoxing.route.GisFieldInfo.preset_spaces)
  return _internal_preset_spaces();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GisFieldInfo::_internal_mutable_preset_spaces() {
  return &_impl_.preset_spaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GisFieldInfo::mutable_preset_spaces() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.GisFieldInfo.preset_spaces)
  return _internal_mutable_preset_spaces();
}

// -------------------------------------------------------------------

// FarmTools

// double width = 1;
inline void FarmTools::clear_width() {
  _impl_.width_ = 0;
}
inline double FarmTools::_internal_width() const {
  return _impl_.width_;
}
inline double FarmTools::width() const {
  // @@protoc_insertion_point(field_get:haoxing.route.FarmTools.width)
  return _internal_width();
}
inline void FarmTools::_internal_set_width(double value) {
  
  _impl_.width_ = value;
}
inline void FarmTools::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:haoxing.route.FarmTools.width)
}

// double length = 2;
inline void FarmTools::clear_length() {
  _impl_.length_ = 0;
}
inline double FarmTools::_internal_length() const {
  return _impl_.length_;
}
inline double FarmTools::length() const {
  // @@protoc_insertion_point(field_get:haoxing.route.FarmTools.length)
  return _internal_length();
}
inline void FarmTools::_internal_set_length(double value) {
  
  _impl_.length_ = value;
}
inline void FarmTools::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:haoxing.route.FarmTools.length)
}

// double leftOffset = 3;
inline void FarmTools::clear_leftoffset() {
  _impl_.leftoffset_ = 0;
}
inline double FarmTools::_internal_leftoffset() const {
  return _impl_.leftoffset_;
}
inline double FarmTools::leftoffset() const {
  // @@protoc_insertion_point(field_get:haoxing.route.FarmTools.leftOffset)
  return _internal_leftoffset();
}
inline void FarmTools::_internal_set_leftoffset(double value) {
  
  _impl_.leftoffset_ = value;
}
inline void FarmTools::set_leftoffset(double value) {
  _internal_set_leftoffset(value);
  // @@protoc_insertion_point(field_set:haoxing.route.FarmTools.leftOffset)
}

// double rightOffset = 4;
inline void FarmTools::clear_rightoffset() {
  _impl_.rightoffset_ = 0;
}
inline double FarmTools::_internal_rightoffset() const {
  return _impl_.rightoffset_;
}
inline double FarmTools::rightoffset() const {
  // @@protoc_insertion_point(field_get:haoxing.route.FarmTools.rightOffset)
  return _internal_rightoffset();
}
inline void FarmTools::_internal_set_rightoffset(double value) {
  
  _impl_.rightoffset_ = value;
}
inline void FarmTools::set_rightoffset(double value) {
  _internal_set_rightoffset(value);
  // @@protoc_insertion_point(field_set:haoxing.route.FarmTools.rightOffset)
}

// -------------------------------------------------------------------

// Vehicle

// double length = 1;
inline void Vehicle::clear_length() {
  _impl_.length_ = 0;
}
inline double Vehicle::_internal_length() const {
  return _impl_.length_;
}
inline double Vehicle::length() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.length)
  return _internal_length();
}
inline void Vehicle::_internal_set_length(double value) {
  
  _impl_.length_ = value;
}
inline void Vehicle::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.length)
}

// bool reverse = 2;
inline void Vehicle::clear_reverse() {
  _impl_.reverse_ = false;
}
inline bool Vehicle::_internal_reverse() const {
  return _impl_.reverse_;
}
inline bool Vehicle::reverse() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.reverse)
  return _internal_reverse();
}
inline void Vehicle::_internal_set_reverse(bool value) {
  
  _impl_.reverse_ = value;
}
inline void Vehicle::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.reverse)
}

// double over_all_width = 3;
inline void Vehicle::clear_over_all_width() {
  _impl_.over_all_width_ = 0;
}
inline double Vehicle::_internal_over_all_width() const {
  return _impl_.over_all_width_;
}
inline double Vehicle::over_all_width() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.over_all_width)
  return _internal_over_all_width();
}
inline void Vehicle::_internal_set_over_all_width(double value) {
  
  _impl_.over_all_width_ = value;
}
inline void Vehicle::set_over_all_width(double value) {
  _internal_set_over_all_width(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.over_all_width)
}

// double front_end_to_location = 4;
inline void Vehicle::clear_front_end_to_location() {
  _impl_.front_end_to_location_ = 0;
}
inline double Vehicle::_internal_front_end_to_location() const {
  return _impl_.front_end_to_location_;
}
inline double Vehicle::front_end_to_location() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.front_end_to_location)
  return _internal_front_end_to_location();
}
inline void Vehicle::_internal_set_front_end_to_location(double value) {
  
  _impl_.front_end_to_location_ = value;
}
inline void Vehicle::set_front_end_to_location(double value) {
  _internal_set_front_end_to_location(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.front_end_to_location)
}

// double rear_end_to_location = 5;
inline void Vehicle::clear_rear_end_to_location() {
  _impl_.rear_end_to_location_ = 0;
}
inline double Vehicle::_internal_rear_end_to_location() const {
  return _impl_.rear_end_to_location_;
}
inline double Vehicle::rear_end_to_location() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.rear_end_to_location)
  return _internal_rear_end_to_location();
}
inline void Vehicle::_internal_set_rear_end_to_location(double value) {
  
  _impl_.rear_end_to_location_ = value;
}
inline void Vehicle::set_rear_end_to_location(double value) {
  _internal_set_rear_end_to_location(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.rear_end_to_location)
}

// double wheel_base = 6;
inline void Vehicle::clear_wheel_base() {
  _impl_.wheel_base_ = 0;
}
inline double Vehicle::_internal_wheel_base() const {
  return _impl_.wheel_base_;
}
inline double Vehicle::wheel_base() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.wheel_base)
  return _internal_wheel_base();
}
inline void Vehicle::_internal_set_wheel_base(double value) {
  
  _impl_.wheel_base_ = value;
}
inline void Vehicle::set_wheel_base(double value) {
  _internal_set_wheel_base(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.wheel_base)
}

// double radius = 7;
inline void Vehicle::clear_radius() {
  _impl_.radius_ = 0;
}
inline double Vehicle::_internal_radius() const {
  return _impl_.radius_;
}
inline double Vehicle::radius() const {
  // @@protoc_insertion_point(field_get:haoxing.route.Vehicle.radius)
  return _internal_radius();
}
inline void Vehicle::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void Vehicle::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:haoxing.route.Vehicle.radius)
}

// -------------------------------------------------------------------

// ObstacleReq

// double x = 1;
inline void ObstacleReq::clear_x() {
  _impl_.x_ = 0;
}
inline double ObstacleReq::_internal_x() const {
  return _impl_.x_;
}
inline double ObstacleReq::x() const {
  // @@protoc_insertion_point(field_get:haoxing.route.ObstacleReq.x)
  return _internal_x();
}
inline void ObstacleReq::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void ObstacleReq::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:haoxing.route.ObstacleReq.x)
}

// double y = 2;
inline void ObstacleReq::clear_y() {
  _impl_.y_ = 0;
}
inline double ObstacleReq::_internal_y() const {
  return _impl_.y_;
}
inline double ObstacleReq::y() const {
  // @@protoc_insertion_point(field_get:haoxing.route.ObstacleReq.y)
  return _internal_y();
}
inline void ObstacleReq::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void ObstacleReq::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:haoxing.route.ObstacleReq.y)
}

// double z = 3;
inline void ObstacleReq::clear_z() {
  _impl_.z_ = 0;
}
inline double ObstacleReq::_internal_z() const {
  return _impl_.z_;
}
inline double ObstacleReq::z() const {
  // @@protoc_insertion_point(field_get:haoxing.route.ObstacleReq.z)
  return _internal_z();
}
inline void ObstacleReq::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void ObstacleReq::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:haoxing.route.ObstacleReq.z)
}

// double r = 4;
inline void ObstacleReq::clear_r() {
  _impl_.r_ = 0;
}
inline double ObstacleReq::_internal_r() const {
  return _impl_.r_;
}
inline double ObstacleReq::r() const {
  // @@protoc_insertion_point(field_get:haoxing.route.ObstacleReq.r)
  return _internal_r();
}
inline void ObstacleReq::_internal_set_r(double value) {
  
  _impl_.r_ = value;
}
inline void ObstacleReq::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:haoxing.route.ObstacleReq.r)
}

// double r_w = 5;
inline void ObstacleReq::clear_r_w() {
  _impl_.r_w_ = 0;
}
inline double ObstacleReq::_internal_r_w() const {
  return _impl_.r_w_;
}
inline double ObstacleReq::r_w() const {
  // @@protoc_insertion_point(field_get:haoxing.route.ObstacleReq.r_w)
  return _internal_r_w();
}
inline void ObstacleReq::_internal_set_r_w(double value) {
  
  _impl_.r_w_ = value;
}
inline void ObstacleReq::set_r_w(double value) {
  _internal_set_r_w(value);
  // @@protoc_insertion_point(field_set:haoxing.route.ObstacleReq.r_w)
}

// int32 taskIndex = 6;
inline void ObstacleReq::clear_taskindex() {
  _impl_.taskindex_ = 0;
}
inline int32_t ObstacleReq::_internal_taskindex() const {
  return _impl_.taskindex_;
}
inline int32_t ObstacleReq::taskindex() const {
  // @@protoc_insertion_point(field_get:haoxing.route.ObstacleReq.taskIndex)
  return _internal_taskindex();
}
inline void ObstacleReq::_internal_set_taskindex(int32_t value) {
  
  _impl_.taskindex_ = value;
}
inline void ObstacleReq::set_taskindex(int32_t value) {
  _internal_set_taskindex(value);
  // @@protoc_insertion_point(field_set:haoxing.route.ObstacleReq.taskIndex)
}

// -------------------------------------------------------------------

// PlanParam

// double lineSpace = 1;
inline void PlanParam::clear_linespace() {
  _impl_.linespace_ = 0;
}
inline double PlanParam::_internal_linespace() const {
  return _impl_.linespace_;
}
inline double PlanParam::linespace() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.lineSpace)
  return _internal_linespace();
}
inline void PlanParam::_internal_set_linespace(double value) {
  
  _impl_.linespace_ = value;
}
inline void PlanParam::set_linespace(double value) {
  _internal_set_linespace(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.lineSpace)
}

// double interspace = 2;
inline void PlanParam::clear_interspace() {
  _impl_.interspace_ = 0;
}
inline double PlanParam::_internal_interspace() const {
  return _impl_.interspace_;
}
inline double PlanParam::interspace() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.interspace)
  return _internal_interspace();
}
inline void PlanParam::_internal_set_interspace(double value) {
  
  _impl_.interspace_ = value;
}
inline void PlanParam::set_interspace(double value) {
  _internal_set_interspace(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.interspace)
}

// double safe_distance = 3;
inline void PlanParam::clear_safe_distance() {
  _impl_.safe_distance_ = 0;
}
inline double PlanParam::_internal_safe_distance() const {
  return _impl_.safe_distance_;
}
inline double PlanParam::safe_distance() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.safe_distance)
  return _internal_safe_distance();
}
inline void PlanParam::_internal_set_safe_distance(double value) {
  
  _impl_.safe_distance_ = value;
}
inline void PlanParam::set_safe_distance(double value) {
  _internal_set_safe_distance(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.safe_distance)
}

// double turn_round_type = 4;
inline void PlanParam::clear_turn_round_type() {
  _impl_.turn_round_type_ = 0;
}
inline double PlanParam::_internal_turn_round_type() const {
  return _impl_.turn_round_type_;
}
inline double PlanParam::turn_round_type() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.turn_round_type)
  return _internal_turn_round_type();
}
inline void PlanParam::_internal_set_turn_round_type(double value) {
  
  _impl_.turn_round_type_ = value;
}
inline void PlanParam::set_turn_round_type(double value) {
  _internal_set_turn_round_type(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.turn_round_type)
}

// double task_type = 5;
inline void PlanParam::clear_task_type() {
  _impl_.task_type_ = 0;
}
inline double PlanParam::_internal_task_type() const {
  return _impl_.task_type_;
}
inline double PlanParam::task_type() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.task_type)
  return _internal_task_type();
}
inline void PlanParam::_internal_set_task_type(double value) {
  
  _impl_.task_type_ = value;
}
inline void PlanParam::set_task_type(double value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.task_type)
}

// double type_seeding = 6;
inline void PlanParam::clear_type_seeding() {
  _impl_.type_seeding_ = 0;
}
inline double PlanParam::_internal_type_seeding() const {
  return _impl_.type_seeding_;
}
inline double PlanParam::type_seeding() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.type_seeding)
  return _internal_type_seeding();
}
inline void PlanParam::_internal_set_type_seeding(double value) {
  
  _impl_.type_seeding_ = value;
}
inline void PlanParam::set_type_seeding(double value) {
  _internal_set_type_seeding(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.type_seeding)
}

// bool modify_orientation = 7;
inline void PlanParam::clear_modify_orientation() {
  _impl_.modify_orientation_ = false;
}
inline bool PlanParam::_internal_modify_orientation() const {
  return _impl_.modify_orientation_;
}
inline bool PlanParam::modify_orientation() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.modify_orientation)
  return _internal_modify_orientation();
}
inline void PlanParam::_internal_set_modify_orientation(bool value) {
  
  _impl_.modify_orientation_ = value;
}
inline void PlanParam::set_modify_orientation(bool value) {
  _internal_set_modify_orientation(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.modify_orientation)
}

// bool acc_overlap = 8;
inline void PlanParam::clear_acc_overlap() {
  _impl_.acc_overlap_ = false;
}
inline bool PlanParam::_internal_acc_overlap() const {
  return _impl_.acc_overlap_;
}
inline bool PlanParam::acc_overlap() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.acc_overlap)
  return _internal_acc_overlap();
}
inline void PlanParam::_internal_set_acc_overlap(bool value) {
  
  _impl_.acc_overlap_ = value;
}
inline void PlanParam::set_acc_overlap(bool value) {
  _internal_set_acc_overlap(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.acc_overlap)
}

// bool multi_vehicle = 9;
inline void PlanParam::clear_multi_vehicle() {
  _impl_.multi_vehicle_ = false;
}
inline bool PlanParam::_internal_multi_vehicle() const {
  return _impl_.multi_vehicle_;
}
inline bool PlanParam::multi_vehicle() const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.multi_vehicle)
  return _internal_multi_vehicle();
}
inline void PlanParam::_internal_set_multi_vehicle(bool value) {
  
  _impl_.multi_vehicle_ = value;
}
inline void PlanParam::set_multi_vehicle(bool value) {
  _internal_set_multi_vehicle(value);
  // @@protoc_insertion_point(field_set:haoxing.route.PlanParam.multi_vehicle)
}

// repeated .haoxing.route.NodeXYZ service_nodes = 10;
inline int PlanParam::_internal_service_nodes_size() const {
  return _impl_.service_nodes_.size();
}
inline int PlanParam::service_nodes_size() const {
  return _internal_service_nodes_size();
}
inline void PlanParam::clear_service_nodes() {
  _impl_.service_nodes_.Clear();
}
inline ::haoxing::route::NodeXYZ* PlanParam::mutable_service_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.PlanParam.service_nodes)
  return _impl_.service_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
PlanParam::mutable_service_nodes() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.PlanParam.service_nodes)
  return &_impl_.service_nodes_;
}
inline const ::haoxing::route::NodeXYZ& PlanParam::_internal_service_nodes(int index) const {
  return _impl_.service_nodes_.Get(index);
}
inline const ::haoxing::route::NodeXYZ& PlanParam::service_nodes(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.PlanParam.service_nodes)
  return _internal_service_nodes(index);
}
inline ::haoxing::route::NodeXYZ* PlanParam::_internal_add_service_nodes() {
  return _impl_.service_nodes_.Add();
}
inline ::haoxing::route::NodeXYZ* PlanParam::add_service_nodes() {
  ::haoxing::route::NodeXYZ* _add = _internal_add_service_nodes();
  // @@protoc_insertion_point(field_add:haoxing.route.PlanParam.service_nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
PlanParam::service_nodes() const {
  // @@protoc_insertion_point(field_list:haoxing.route.PlanParam.service_nodes)
  return _impl_.service_nodes_;
}

// -------------------------------------------------------------------

// RoadPlanRequest

// .haoxing.route.GisFieldInfo gisFieldInfo = 1;
inline bool RoadPlanRequest::_internal_has_gisfieldinfo() const {
  return this != internal_default_instance() && _impl_.gisfieldinfo_ != nullptr;
}
inline bool RoadPlanRequest::has_gisfieldinfo() const {
  return _internal_has_gisfieldinfo();
}
inline void RoadPlanRequest::clear_gisfieldinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.gisfieldinfo_ != nullptr) {
    delete _impl_.gisfieldinfo_;
  }
  _impl_.gisfieldinfo_ = nullptr;
}
inline const ::haoxing::route::GisFieldInfo& RoadPlanRequest::_internal_gisfieldinfo() const {
  const ::haoxing::route::GisFieldInfo* p = _impl_.gisfieldinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::GisFieldInfo&>(
      ::haoxing::route::_GisFieldInfo_default_instance_);
}
inline const ::haoxing::route::GisFieldInfo& RoadPlanRequest::gisfieldinfo() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RoadPlanRequest.gisFieldInfo)
  return _internal_gisfieldinfo();
}
inline void RoadPlanRequest::unsafe_arena_set_allocated_gisfieldinfo(
    ::haoxing::route::GisFieldInfo* gisfieldinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gisfieldinfo_);
  }
  _impl_.gisfieldinfo_ = gisfieldinfo;
  if (gisfieldinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.RoadPlanRequest.gisFieldInfo)
}
inline ::haoxing::route::GisFieldInfo* RoadPlanRequest::release_gisfieldinfo() {
  
  ::haoxing::route::GisFieldInfo* temp = _impl_.gisfieldinfo_;
  _impl_.gisfieldinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::GisFieldInfo* RoadPlanRequest::unsafe_arena_release_gisfieldinfo() {
  // @@protoc_insertion_point(field_release:haoxing.route.RoadPlanRequest.gisFieldInfo)
  
  ::haoxing::route::GisFieldInfo* temp = _impl_.gisfieldinfo_;
  _impl_.gisfieldinfo_ = nullptr;
  return temp;
}
inline ::haoxing::route::GisFieldInfo* RoadPlanRequest::_internal_mutable_gisfieldinfo() {
  
  if (_impl_.gisfieldinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::GisFieldInfo>(GetArenaForAllocation());
    _impl_.gisfieldinfo_ = p;
  }
  return _impl_.gisfieldinfo_;
}
inline ::haoxing::route::GisFieldInfo* RoadPlanRequest::mutable_gisfieldinfo() {
  ::haoxing::route::GisFieldInfo* _msg = _internal_mutable_gisfieldinfo();
  // @@protoc_insertion_point(field_mutable:haoxing.route.RoadPlanRequest.gisFieldInfo)
  return _msg;
}
inline void RoadPlanRequest::set_allocated_gisfieldinfo(::haoxing::route::GisFieldInfo* gisfieldinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gisfieldinfo_;
  }
  if (gisfieldinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gisfieldinfo);
    if (message_arena != submessage_arena) {
      gisfieldinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gisfieldinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gisfieldinfo_ = gisfieldinfo;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.RoadPlanRequest.gisFieldInfo)
}

// .haoxing.route.FarmTools farmTools = 2;
inline bool RoadPlanRequest::_internal_has_farmtools() const {
  return this != internal_default_instance() && _impl_.farmtools_ != nullptr;
}
inline bool RoadPlanRequest::has_farmtools() const {
  return _internal_has_farmtools();
}
inline void RoadPlanRequest::clear_farmtools() {
  if (GetArenaForAllocation() == nullptr && _impl_.farmtools_ != nullptr) {
    delete _impl_.farmtools_;
  }
  _impl_.farmtools_ = nullptr;
}
inline const ::haoxing::route::FarmTools& RoadPlanRequest::_internal_farmtools() const {
  const ::haoxing::route::FarmTools* p = _impl_.farmtools_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::FarmTools&>(
      ::haoxing::route::_FarmTools_default_instance_);
}
inline const ::haoxing::route::FarmTools& RoadPlanRequest::farmtools() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RoadPlanRequest.farmTools)
  return _internal_farmtools();
}
inline void RoadPlanRequest::unsafe_arena_set_allocated_farmtools(
    ::haoxing::route::FarmTools* farmtools) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.farmtools_);
  }
  _impl_.farmtools_ = farmtools;
  if (farmtools) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.RoadPlanRequest.farmTools)
}
inline ::haoxing::route::FarmTools* RoadPlanRequest::release_farmtools() {
  
  ::haoxing::route::FarmTools* temp = _impl_.farmtools_;
  _impl_.farmtools_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::FarmTools* RoadPlanRequest::unsafe_arena_release_farmtools() {
  // @@protoc_insertion_point(field_release:haoxing.route.RoadPlanRequest.farmTools)
  
  ::haoxing::route::FarmTools* temp = _impl_.farmtools_;
  _impl_.farmtools_ = nullptr;
  return temp;
}
inline ::haoxing::route::FarmTools* RoadPlanRequest::_internal_mutable_farmtools() {
  
  if (_impl_.farmtools_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::FarmTools>(GetArenaForAllocation());
    _impl_.farmtools_ = p;
  }
  return _impl_.farmtools_;
}
inline ::haoxing::route::FarmTools* RoadPlanRequest::mutable_farmtools() {
  ::haoxing::route::FarmTools* _msg = _internal_mutable_farmtools();
  // @@protoc_insertion_point(field_mutable:haoxing.route.RoadPlanRequest.farmTools)
  return _msg;
}
inline void RoadPlanRequest::set_allocated_farmtools(::haoxing::route::FarmTools* farmtools) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.farmtools_;
  }
  if (farmtools) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(farmtools);
    if (message_arena != submessage_arena) {
      farmtools = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, farmtools, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.farmtools_ = farmtools;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.RoadPlanRequest.farmTools)
}

// .haoxing.route.Vehicle vehicle = 3;
inline bool RoadPlanRequest::_internal_has_vehicle() const {
  return this != internal_default_instance() && _impl_.vehicle_ != nullptr;
}
inline bool RoadPlanRequest::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void RoadPlanRequest::clear_vehicle() {
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
}
inline const ::haoxing::route::Vehicle& RoadPlanRequest::_internal_vehicle() const {
  const ::haoxing::route::Vehicle* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::Vehicle&>(
      ::haoxing::route::_Vehicle_default_instance_);
}
inline const ::haoxing::route::Vehicle& RoadPlanRequest::vehicle() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RoadPlanRequest.vehicle)
  return _internal_vehicle();
}
inline void RoadPlanRequest::unsafe_arena_set_allocated_vehicle(
    ::haoxing::route::Vehicle* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.RoadPlanRequest.vehicle)
}
inline ::haoxing::route::Vehicle* RoadPlanRequest::release_vehicle() {
  
  ::haoxing::route::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::Vehicle* RoadPlanRequest::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:haoxing.route.RoadPlanRequest.vehicle)
  
  ::haoxing::route::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::haoxing::route::Vehicle* RoadPlanRequest::_internal_mutable_vehicle() {
  
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::Vehicle>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::haoxing::route::Vehicle* RoadPlanRequest::mutable_vehicle() {
  ::haoxing::route::Vehicle* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:haoxing.route.RoadPlanRequest.vehicle)
  return _msg;
}
inline void RoadPlanRequest::set_allocated_vehicle(::haoxing::route::Vehicle* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.RoadPlanRequest.vehicle)
}

// .haoxing.route.PlanParam planParam = 4;
inline bool RoadPlanRequest::_internal_has_planparam() const {
  return this != internal_default_instance() && _impl_.planparam_ != nullptr;
}
inline bool RoadPlanRequest::has_planparam() const {
  return _internal_has_planparam();
}
inline void RoadPlanRequest::clear_planparam() {
  if (GetArenaForAllocation() == nullptr && _impl_.planparam_ != nullptr) {
    delete _impl_.planparam_;
  }
  _impl_.planparam_ = nullptr;
}
inline const ::haoxing::route::PlanParam& RoadPlanRequest::_internal_planparam() const {
  const ::haoxing::route::PlanParam* p = _impl_.planparam_;
  return p != nullptr ? *p : reinterpret_cast<const ::haoxing::route::PlanParam&>(
      ::haoxing::route::_PlanParam_default_instance_);
}
inline const ::haoxing::route::PlanParam& RoadPlanRequest::planparam() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RoadPlanRequest.planParam)
  return _internal_planparam();
}
inline void RoadPlanRequest::unsafe_arena_set_allocated_planparam(
    ::haoxing::route::PlanParam* planparam) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.planparam_);
  }
  _impl_.planparam_ = planparam;
  if (planparam) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:haoxing.route.RoadPlanRequest.planParam)
}
inline ::haoxing::route::PlanParam* RoadPlanRequest::release_planparam() {
  
  ::haoxing::route::PlanParam* temp = _impl_.planparam_;
  _impl_.planparam_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::haoxing::route::PlanParam* RoadPlanRequest::unsafe_arena_release_planparam() {
  // @@protoc_insertion_point(field_release:haoxing.route.RoadPlanRequest.planParam)
  
  ::haoxing::route::PlanParam* temp = _impl_.planparam_;
  _impl_.planparam_ = nullptr;
  return temp;
}
inline ::haoxing::route::PlanParam* RoadPlanRequest::_internal_mutable_planparam() {
  
  if (_impl_.planparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::haoxing::route::PlanParam>(GetArenaForAllocation());
    _impl_.planparam_ = p;
  }
  return _impl_.planparam_;
}
inline ::haoxing::route::PlanParam* RoadPlanRequest::mutable_planparam() {
  ::haoxing::route::PlanParam* _msg = _internal_mutable_planparam();
  // @@protoc_insertion_point(field_mutable:haoxing.route.RoadPlanRequest.planParam)
  return _msg;
}
inline void RoadPlanRequest::set_allocated_planparam(::haoxing::route::PlanParam* planparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.planparam_;
  }
  if (planparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(planparam);
    if (message_arena != submessage_arena) {
      planparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planparam, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.planparam_ = planparam;
  // @@protoc_insertion_point(field_set_allocated:haoxing.route.RoadPlanRequest.planParam)
}

// -------------------------------------------------------------------

// RoadPlanRespond

// repeated .haoxing.route.NodeXYZ nodes = 1;
inline int RoadPlanRespond::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int RoadPlanRespond::nodes_size() const {
  return _internal_nodes_size();
}
inline void RoadPlanRespond::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::haoxing::route::NodeXYZ* RoadPlanRespond::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:haoxing.route.RoadPlanRespond.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >*
RoadPlanRespond::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:haoxing.route.RoadPlanRespond.nodes)
  return &_impl_.nodes_;
}
inline const ::haoxing::route::NodeXYZ& RoadPlanRespond::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::haoxing::route::NodeXYZ& RoadPlanRespond::nodes(int index) const {
  // @@protoc_insertion_point(field_get:haoxing.route.RoadPlanRespond.nodes)
  return _internal_nodes(index);
}
inline ::haoxing::route::NodeXYZ* RoadPlanRespond::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::haoxing::route::NodeXYZ* RoadPlanRespond::add_nodes() {
  ::haoxing::route::NodeXYZ* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:haoxing.route.RoadPlanRespond.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::haoxing::route::NodeXYZ >&
RoadPlanRespond::nodes() const {
  // @@protoc_insertion_point(field_list:haoxing.route.RoadPlanRespond.nodes)
  return _impl_.nodes_;
}

// double mileage = 2;
inline void RoadPlanRespond::clear_mileage() {
  _impl_.mileage_ = 0;
}
inline double RoadPlanRespond::_internal_mileage() const {
  return _impl_.mileage_;
}
inline double RoadPlanRespond::mileage() const {
  // @@protoc_insertion_point(field_get:haoxing.route.RoadPlanRespond.mileage)
  return _internal_mileage();
}
inline void RoadPlanRespond::_internal_set_mileage(double value) {
  
  _impl_.mileage_ = value;
}
inline void RoadPlanRespond::set_mileage(double value) {
  _internal_set_mileage(value);
  // @@protoc_insertion_point(field_set:haoxing.route.RoadPlanRespond.mileage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace route
}  // namespace haoxing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_route_2eproto
