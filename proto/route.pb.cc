// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#include "route.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace haoxing {
namespace route {
PROTOBUF_CONSTEXPR NodeXYZ::NodeXYZ(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.yaw_)*/0
  , /*decltype(_impl_.v_)*/0
  , /*decltype(_impl_.s_)*/0
  , /*decltype(_impl_.curvature_)*/0
  , /*decltype(_impl_.back_)*/0
  , /*decltype(_impl_.str_cur_)*/0
  , /*decltype(_impl_.reverse_)*/false
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeXYZDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeXYZDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeXYZDefaultTypeInternal() {}
  union {
    NodeXYZ _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeXYZDefaultTypeInternal _NodeXYZ_default_instance_;
PROTOBUF_CONSTEXPR GisFieldInfo::GisFieldInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fieldnodes_)*/{}
  , /*decltype(_impl_.obstaclereq_)*/{}
  , /*decltype(_impl_.preset_spaces_)*/{}
  , /*decltype(_impl_.entrance_node_)*/nullptr
  , /*decltype(_impl_.exit_node_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GisFieldInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GisFieldInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GisFieldInfoDefaultTypeInternal() {}
  union {
    GisFieldInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GisFieldInfoDefaultTypeInternal _GisFieldInfo_default_instance_;
PROTOBUF_CONSTEXPR FarmTools::FarmTools(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.length_)*/0
  , /*decltype(_impl_.leftoffset_)*/0
  , /*decltype(_impl_.rightoffset_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FarmToolsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FarmToolsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FarmToolsDefaultTypeInternal() {}
  union {
    FarmTools _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FarmToolsDefaultTypeInternal _FarmTools_default_instance_;
PROTOBUF_CONSTEXPR Vehicle::Vehicle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.length_)*/0
  , /*decltype(_impl_.over_all_width_)*/0
  , /*decltype(_impl_.front_end_to_location_)*/0
  , /*decltype(_impl_.rear_end_to_location_)*/0
  , /*decltype(_impl_.wheel_base_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.reverse_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VehicleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VehicleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VehicleDefaultTypeInternal() {}
  union {
    Vehicle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VehicleDefaultTypeInternal _Vehicle_default_instance_;
PROTOBUF_CONSTEXPR ObstacleReq::ObstacleReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.r_)*/0
  , /*decltype(_impl_.r_w_)*/0
  , /*decltype(_impl_.taskindex_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ObstacleReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObstacleReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObstacleReqDefaultTypeInternal() {}
  union {
    ObstacleReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObstacleReqDefaultTypeInternal _ObstacleReq_default_instance_;
PROTOBUF_CONSTEXPR PlanParam::PlanParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.service_nodes_)*/{}
  , /*decltype(_impl_.linespace_)*/0
  , /*decltype(_impl_.interspace_)*/0
  , /*decltype(_impl_.safe_distance_)*/0
  , /*decltype(_impl_.turn_round_type_)*/0
  , /*decltype(_impl_.task_type_)*/0
  , /*decltype(_impl_.type_seeding_)*/0
  , /*decltype(_impl_.modify_orientation_)*/false
  , /*decltype(_impl_.acc_overlap_)*/false
  , /*decltype(_impl_.multi_vehicle_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlanParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanParamDefaultTypeInternal() {}
  union {
    PlanParam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanParamDefaultTypeInternal _PlanParam_default_instance_;
PROTOBUF_CONSTEXPR RoadPlanRequest::RoadPlanRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gisfieldinfo_)*/nullptr
  , /*decltype(_impl_.farmtools_)*/nullptr
  , /*decltype(_impl_.vehicle_)*/nullptr
  , /*decltype(_impl_.planparam_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RoadPlanRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoadPlanRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoadPlanRequestDefaultTypeInternal() {}
  union {
    RoadPlanRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoadPlanRequestDefaultTypeInternal _RoadPlanRequest_default_instance_;
PROTOBUF_CONSTEXPR RoadPlanRespond::RoadPlanRespond(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_.mileage_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RoadPlanRespondDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoadPlanRespondDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoadPlanRespondDefaultTypeInternal() {}
  union {
    RoadPlanRespond _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoadPlanRespondDefaultTypeInternal _RoadPlanRespond_default_instance_;
}  // namespace route
}  // namespace haoxing
static ::_pb::Metadata file_level_metadata_route_2eproto[8];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_route_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_route_2eproto = nullptr;

const uint32_t TableStruct_route_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.yaw_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.v_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.s_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.curvature_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.back_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.str_cur_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.reverse_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::GisFieldInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::GisFieldInfo, _impl_.entrance_node_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::GisFieldInfo, _impl_.exit_node_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::GisFieldInfo, _impl_.fieldnodes_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::GisFieldInfo, _impl_.obstaclereq_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::GisFieldInfo, _impl_.preset_spaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FarmTools, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FarmTools, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FarmTools, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FarmTools, _impl_.leftoffset_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FarmTools, _impl_.rightoffset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.reverse_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.over_all_width_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.front_end_to_location_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.rear_end_to_location_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.wheel_base_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.radius_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ObstacleReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ObstacleReq, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ObstacleReq, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ObstacleReq, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ObstacleReq, _impl_.r_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ObstacleReq, _impl_.r_w_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ObstacleReq, _impl_.taskindex_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.linespace_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.interspace_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.safe_distance_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.turn_round_type_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.task_type_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.type_seeding_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.modify_orientation_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.acc_overlap_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.multi_vehicle_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.service_nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRequest, _impl_.gisfieldinfo_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRequest, _impl_.farmtools_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRequest, _impl_.vehicle_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRequest, _impl_.planparam_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRespond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRespond, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RoadPlanRespond, _impl_.mileage_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::haoxing::route::NodeXYZ)},
  { 17, -1, -1, sizeof(::haoxing::route::GisFieldInfo)},
  { 28, -1, -1, sizeof(::haoxing::route::FarmTools)},
  { 38, -1, -1, sizeof(::haoxing::route::Vehicle)},
  { 51, -1, -1, sizeof(::haoxing::route::ObstacleReq)},
  { 63, -1, -1, sizeof(::haoxing::route::PlanParam)},
  { 79, -1, -1, sizeof(::haoxing::route::RoadPlanRequest)},
  { 89, -1, -1, sizeof(::haoxing::route::RoadPlanRespond)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::haoxing::route::_NodeXYZ_default_instance_._instance,
  &::haoxing::route::_GisFieldInfo_default_instance_._instance,
  &::haoxing::route::_FarmTools_default_instance_._instance,
  &::haoxing::route::_Vehicle_default_instance_._instance,
  &::haoxing::route::_ObstacleReq_default_instance_._instance,
  &::haoxing::route::_PlanParam_default_instance_._instance,
  &::haoxing::route::_RoadPlanRequest_default_instance_._instance,
  &::haoxing::route::_RoadPlanRespond_default_instance_._instance,
};

const char descriptor_table_protodef_route_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013route.proto\022\rhaoxing.route\"\236\001\n\007NodeXYZ"
  "\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\013\n\003yaw"
  "\030\004 \001(\001\022\t\n\001v\030\005 \001(\001\022\t\n\001s\030\006 \001(\001\022\021\n\tcurvatur"
  "e\030\007 \001(\001\022\014\n\004back\030\010 \001(\005\022\017\n\007str_cur\030\t \001(\005\022\017"
  "\n\007reverse\030\n \001(\010\022\014\n\004type\030\013 \001(\005\"\334\001\n\014GisFie"
  "ldInfo\022-\n\rentrance_node\030\001 \001(\0132\026.haoxing."
  "route.NodeXYZ\022)\n\texit_node\030\002 \001(\0132\026.haoxi"
  "ng.route.NodeXYZ\022*\n\nfieldNodes\030\003 \003(\0132\026.h"
  "aoxing.route.NodeXYZ\022/\n\013obstacleReq\030\004 \003("
  "\0132\032.haoxing.route.ObstacleReq\022\025\n\rpreset_"
  "spaces\030\005 \003(\001\"S\n\tFarmTools\022\r\n\005width\030\001 \001(\001"
  "\022\016\n\006length\030\002 \001(\001\022\022\n\nleftOffset\030\003 \001(\001\022\023\n\013"
  "rightOffset\030\004 \001(\001\"\243\001\n\007Vehicle\022\016\n\006length\030"
  "\001 \001(\001\022\017\n\007reverse\030\002 \001(\010\022\026\n\016over_all_width"
  "\030\003 \001(\001\022\035\n\025front_end_to_location\030\004 \001(\001\022\034\n"
  "\024rear_end_to_location\030\005 \001(\001\022\022\n\nwheel_bas"
  "e\030\006 \001(\001\022\016\n\006radius\030\007 \001(\001\"Y\n\013ObstacleReq\022\t"
  "\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\t\n\001r\030\004 \001"
  "(\001\022\013\n\003r_w\030\005 \001(\001\022\021\n\ttaskIndex\030\006 \001(\005\"\202\002\n\tP"
  "lanParam\022\021\n\tlineSpace\030\001 \001(\001\022\022\n\ninterspac"
  "e\030\002 \001(\001\022\025\n\rsafe_distance\030\003 \001(\001\022\027\n\017turn_r"
  "ound_type\030\004 \001(\001\022\021\n\ttask_type\030\005 \001(\001\022\024\n\014ty"
  "pe_seeding\030\006 \001(\001\022\032\n\022modify_orientation\030\007"
  " \001(\010\022\023\n\013acc_overlap\030\010 \001(\010\022\025\n\rmulti_vehic"
  "le\030\t \001(\010\022-\n\rservice_nodes\030\n \003(\0132\026.haoxin"
  "g.route.NodeXYZ\"\307\001\n\017RoadPlanRequest\0221\n\014g"
  "isFieldInfo\030\001 \001(\0132\033.haoxing.route.GisFie"
  "ldInfo\022+\n\tfarmTools\030\002 \001(\0132\030.haoxing.rout"
  "e.FarmTools\022\'\n\007vehicle\030\003 \001(\0132\026.haoxing.r"
  "oute.Vehicle\022+\n\tplanParam\030\004 \001(\0132\030.haoxin"
  "g.route.PlanParam\"I\n\017RoadPlanRespond\022%\n\005"
  "nodes\030\001 \003(\0132\026.haoxing.route.NodeXYZ\022\017\n\007m"
  "ileage\030\002 \001(\0012c\n\017RoadPlanService\022P\n\016GetNo"
  "deXYZList\022\036.haoxing.route.RoadPlanReques"
  "t\032\036.haoxing.route.RoadPlanRespondB7\n\036com"
  ".hx.schedule.algorithm.grpcB\014RoutingProt"
  "oP\001\242\002\004hxkjb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_route_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_route_2eproto = {
    false, false, 1458, descriptor_table_protodef_route_2eproto,
    "route.proto",
    &descriptor_table_route_2eproto_once, nullptr, 0, 8,
    schemas, file_default_instances, TableStruct_route_2eproto::offsets,
    file_level_metadata_route_2eproto, file_level_enum_descriptors_route_2eproto,
    file_level_service_descriptors_route_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_route_2eproto_getter() {
  return &descriptor_table_route_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_route_2eproto(&descriptor_table_route_2eproto);
namespace haoxing {
namespace route {

// ===================================================================

class NodeXYZ::_Internal {
 public:
};

NodeXYZ::NodeXYZ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.NodeXYZ)
}
NodeXYZ::NodeXYZ(const NodeXYZ& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeXYZ* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.yaw_){}
    , decltype(_impl_.v_){}
    , decltype(_impl_.s_){}
    , decltype(_impl_.curvature_){}
    , decltype(_impl_.back_){}
    , decltype(_impl_.str_cur_){}
    , decltype(_impl_.reverse_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.NodeXYZ)
}

inline void NodeXYZ::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.yaw_){0}
    , decltype(_impl_.v_){0}
    , decltype(_impl_.s_){0}
    , decltype(_impl_.curvature_){0}
    , decltype(_impl_.back_){0}
    , decltype(_impl_.str_cur_){0}
    , decltype(_impl_.reverse_){false}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodeXYZ::~NodeXYZ() {
  // @@protoc_insertion_point(destructor:haoxing.route.NodeXYZ)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeXYZ::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NodeXYZ::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeXYZ::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.NodeXYZ)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeXYZ::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double yaw = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double v = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.v_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double s = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double curvature = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.curvature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 back = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.back_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 str_cur = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.str_cur_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reverse = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeXYZ::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.NodeXYZ)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double yaw = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_yaw(), target);
  }

  // double v = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_v = this->_internal_v();
  uint64_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_v(), target);
  }

  // double s = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_s = this->_internal_s();
  uint64_t raw_s;
  memcpy(&raw_s, &tmp_s, sizeof(tmp_s));
  if (raw_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_s(), target);
  }

  // double curvature = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curvature = this->_internal_curvature();
  uint64_t raw_curvature;
  memcpy(&raw_curvature, &tmp_curvature, sizeof(tmp_curvature));
  if (raw_curvature != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_curvature(), target);
  }

  // int32 back = 8;
  if (this->_internal_back() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_back(), target);
  }

  // int32 str_cur = 9;
  if (this->_internal_str_cur() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_str_cur(), target);
  }

  // bool reverse = 10;
  if (this->_internal_reverse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_reverse(), target);
  }

  // int32 type = 11;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.NodeXYZ)
  return target;
}

size_t NodeXYZ::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.NodeXYZ)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double yaw = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 1 + 8;
  }

  // double v = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_v = this->_internal_v();
  uint64_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    total_size += 1 + 8;
  }

  // double s = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_s = this->_internal_s();
  uint64_t raw_s;
  memcpy(&raw_s, &tmp_s, sizeof(tmp_s));
  if (raw_s != 0) {
    total_size += 1 + 8;
  }

  // double curvature = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curvature = this->_internal_curvature();
  uint64_t raw_curvature;
  memcpy(&raw_curvature, &tmp_curvature, sizeof(tmp_curvature));
  if (raw_curvature != 0) {
    total_size += 1 + 8;
  }

  // int32 back = 8;
  if (this->_internal_back() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_back());
  }

  // int32 str_cur = 9;
  if (this->_internal_str_cur() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_str_cur());
  }

  // bool reverse = 10;
  if (this->_internal_reverse() != 0) {
    total_size += 1 + 1;
  }

  // int32 type = 11;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeXYZ::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeXYZ::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeXYZ::GetClassData() const { return &_class_data_; }


void NodeXYZ::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeXYZ*>(&to_msg);
  auto& from = static_cast<const NodeXYZ&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.NodeXYZ)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_yaw = from._internal_yaw();
  uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_v = from._internal_v();
  uint64_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    _this->_internal_set_v(from._internal_v());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_s = from._internal_s();
  uint64_t raw_s;
  memcpy(&raw_s, &tmp_s, sizeof(tmp_s));
  if (raw_s != 0) {
    _this->_internal_set_s(from._internal_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curvature = from._internal_curvature();
  uint64_t raw_curvature;
  memcpy(&raw_curvature, &tmp_curvature, sizeof(tmp_curvature));
  if (raw_curvature != 0) {
    _this->_internal_set_curvature(from._internal_curvature());
  }
  if (from._internal_back() != 0) {
    _this->_internal_set_back(from._internal_back());
  }
  if (from._internal_str_cur() != 0) {
    _this->_internal_set_str_cur(from._internal_str_cur());
  }
  if (from._internal_reverse() != 0) {
    _this->_internal_set_reverse(from._internal_reverse());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeXYZ::CopyFrom(const NodeXYZ& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.NodeXYZ)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeXYZ::IsInitialized() const {
  return true;
}

void NodeXYZ::InternalSwap(NodeXYZ* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeXYZ, _impl_.type_)
      + sizeof(NodeXYZ::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(NodeXYZ, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeXYZ::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[0]);
}

// ===================================================================

class GisFieldInfo::_Internal {
 public:
  static const ::haoxing::route::NodeXYZ& entrance_node(const GisFieldInfo* msg);
  static const ::haoxing::route::NodeXYZ& exit_node(const GisFieldInfo* msg);
};

const ::haoxing::route::NodeXYZ&
GisFieldInfo::_Internal::entrance_node(const GisFieldInfo* msg) {
  return *msg->_impl_.entrance_node_;
}
const ::haoxing::route::NodeXYZ&
GisFieldInfo::_Internal::exit_node(const GisFieldInfo* msg) {
  return *msg->_impl_.exit_node_;
}
GisFieldInfo::GisFieldInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.GisFieldInfo)
}
GisFieldInfo::GisFieldInfo(const GisFieldInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GisFieldInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fieldnodes_){from._impl_.fieldnodes_}
    , decltype(_impl_.obstaclereq_){from._impl_.obstaclereq_}
    , decltype(_impl_.preset_spaces_){from._impl_.preset_spaces_}
    , decltype(_impl_.entrance_node_){nullptr}
    , decltype(_impl_.exit_node_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_entrance_node()) {
    _this->_impl_.entrance_node_ = new ::haoxing::route::NodeXYZ(*from._impl_.entrance_node_);
  }
  if (from._internal_has_exit_node()) {
    _this->_impl_.exit_node_ = new ::haoxing::route::NodeXYZ(*from._impl_.exit_node_);
  }
  // @@protoc_insertion_point(copy_constructor:haoxing.route.GisFieldInfo)
}

inline void GisFieldInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fieldnodes_){arena}
    , decltype(_impl_.obstaclereq_){arena}
    , decltype(_impl_.preset_spaces_){arena}
    , decltype(_impl_.entrance_node_){nullptr}
    , decltype(_impl_.exit_node_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GisFieldInfo::~GisFieldInfo() {
  // @@protoc_insertion_point(destructor:haoxing.route.GisFieldInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GisFieldInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fieldnodes_.~RepeatedPtrField();
  _impl_.obstaclereq_.~RepeatedPtrField();
  _impl_.preset_spaces_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.entrance_node_;
  if (this != internal_default_instance()) delete _impl_.exit_node_;
}

void GisFieldInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GisFieldInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.GisFieldInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fieldnodes_.Clear();
  _impl_.obstaclereq_.Clear();
  _impl_.preset_spaces_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.entrance_node_ != nullptr) {
    delete _impl_.entrance_node_;
  }
  _impl_.entrance_node_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.exit_node_ != nullptr) {
    delete _impl_.exit_node_;
  }
  _impl_.exit_node_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GisFieldInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .haoxing.route.NodeXYZ entrance_node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_entrance_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.NodeXYZ exit_node = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_exit_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fieldnodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .haoxing.route.ObstacleReq obstacleReq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_obstaclereq(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double preset_spaces = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_preset_spaces(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_preset_spaces(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GisFieldInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.GisFieldInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .haoxing.route.NodeXYZ entrance_node = 1;
  if (this->_internal_has_entrance_node()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::entrance_node(this),
        _Internal::entrance_node(this).GetCachedSize(), target, stream);
  }

  // .haoxing.route.NodeXYZ exit_node = 2;
  if (this->_internal_has_exit_node()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::exit_node(this),
        _Internal::exit_node(this).GetCachedSize(), target, stream);
  }

  // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fieldnodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_fieldnodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .haoxing.route.ObstacleReq obstacleReq = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_obstaclereq_size()); i < n; i++) {
    const auto& repfield = this->_internal_obstaclereq(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated double preset_spaces = 5;
  if (this->_internal_preset_spaces_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_preset_spaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.GisFieldInfo)
  return target;
}

size_t GisFieldInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.GisFieldInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
  total_size += 1UL * this->_internal_fieldnodes_size();
  for (const auto& msg : this->_impl_.fieldnodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .haoxing.route.ObstacleReq obstacleReq = 4;
  total_size += 1UL * this->_internal_obstaclereq_size();
  for (const auto& msg : this->_impl_.obstaclereq_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double preset_spaces = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_preset_spaces_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .haoxing.route.NodeXYZ entrance_node = 1;
  if (this->_internal_has_entrance_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.entrance_node_);
  }

  // .haoxing.route.NodeXYZ exit_node = 2;
  if (this->_internal_has_exit_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.exit_node_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GisFieldInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GisFieldInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GisFieldInfo::GetClassData() const { return &_class_data_; }


void GisFieldInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GisFieldInfo*>(&to_msg);
  auto& from = static_cast<const GisFieldInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.GisFieldInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fieldnodes_.MergeFrom(from._impl_.fieldnodes_);
  _this->_impl_.obstaclereq_.MergeFrom(from._impl_.obstaclereq_);
  _this->_impl_.preset_spaces_.MergeFrom(from._impl_.preset_spaces_);
  if (from._internal_has_entrance_node()) {
    _this->_internal_mutable_entrance_node()->::haoxing::route::NodeXYZ::MergeFrom(
        from._internal_entrance_node());
  }
  if (from._internal_has_exit_node()) {
    _this->_internal_mutable_exit_node()->::haoxing::route::NodeXYZ::MergeFrom(
        from._internal_exit_node());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GisFieldInfo::CopyFrom(const GisFieldInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.GisFieldInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GisFieldInfo::IsInitialized() const {
  return true;
}

void GisFieldInfo::InternalSwap(GisFieldInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fieldnodes_.InternalSwap(&other->_impl_.fieldnodes_);
  _impl_.obstaclereq_.InternalSwap(&other->_impl_.obstaclereq_);
  _impl_.preset_spaces_.InternalSwap(&other->_impl_.preset_spaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GisFieldInfo, _impl_.exit_node_)
      + sizeof(GisFieldInfo::_impl_.exit_node_)
      - PROTOBUF_FIELD_OFFSET(GisFieldInfo, _impl_.entrance_node_)>(
          reinterpret_cast<char*>(&_impl_.entrance_node_),
          reinterpret_cast<char*>(&other->_impl_.entrance_node_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GisFieldInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[1]);
}

// ===================================================================

class FarmTools::_Internal {
 public:
};

FarmTools::FarmTools(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.FarmTools)
}
FarmTools::FarmTools(const FarmTools& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FarmTools* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){}
    , decltype(_impl_.length_){}
    , decltype(_impl_.leftoffset_){}
    , decltype(_impl_.rightoffset_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rightoffset_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.rightoffset_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.FarmTools)
}

inline void FarmTools::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){0}
    , decltype(_impl_.length_){0}
    , decltype(_impl_.leftoffset_){0}
    , decltype(_impl_.rightoffset_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FarmTools::~FarmTools() {
  // @@protoc_insertion_point(destructor:haoxing.route.FarmTools)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FarmTools::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FarmTools::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FarmTools::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.FarmTools)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rightoffset_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.rightoffset_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FarmTools::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double leftOffset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.leftoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rightOffset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.rightoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FarmTools::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.FarmTools)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double width = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_width(), target);
  }

  // double length = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_length(), target);
  }

  // double leftOffset = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_leftoffset = this->_internal_leftoffset();
  uint64_t raw_leftoffset;
  memcpy(&raw_leftoffset, &tmp_leftoffset, sizeof(tmp_leftoffset));
  if (raw_leftoffset != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_leftoffset(), target);
  }

  // double rightOffset = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rightoffset = this->_internal_rightoffset();
  uint64_t raw_rightoffset;
  memcpy(&raw_rightoffset, &tmp_rightoffset, sizeof(tmp_rightoffset));
  if (raw_rightoffset != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_rightoffset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.FarmTools)
  return target;
}

size_t FarmTools::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.FarmTools)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double width = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 8;
  }

  // double length = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 1 + 8;
  }

  // double leftOffset = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_leftoffset = this->_internal_leftoffset();
  uint64_t raw_leftoffset;
  memcpy(&raw_leftoffset, &tmp_leftoffset, sizeof(tmp_leftoffset));
  if (raw_leftoffset != 0) {
    total_size += 1 + 8;
  }

  // double rightOffset = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rightoffset = this->_internal_rightoffset();
  uint64_t raw_rightoffset;
  memcpy(&raw_rightoffset, &tmp_rightoffset, sizeof(tmp_rightoffset));
  if (raw_rightoffset != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FarmTools::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FarmTools::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FarmTools::GetClassData() const { return &_class_data_; }


void FarmTools::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FarmTools*>(&to_msg);
  auto& from = static_cast<const FarmTools&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.FarmTools)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = from._internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = from._internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_leftoffset = from._internal_leftoffset();
  uint64_t raw_leftoffset;
  memcpy(&raw_leftoffset, &tmp_leftoffset, sizeof(tmp_leftoffset));
  if (raw_leftoffset != 0) {
    _this->_internal_set_leftoffset(from._internal_leftoffset());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rightoffset = from._internal_rightoffset();
  uint64_t raw_rightoffset;
  memcpy(&raw_rightoffset, &tmp_rightoffset, sizeof(tmp_rightoffset));
  if (raw_rightoffset != 0) {
    _this->_internal_set_rightoffset(from._internal_rightoffset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FarmTools::CopyFrom(const FarmTools& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.FarmTools)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FarmTools::IsInitialized() const {
  return true;
}

void FarmTools::InternalSwap(FarmTools* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FarmTools, _impl_.rightoffset_)
      + sizeof(FarmTools::_impl_.rightoffset_)
      - PROTOBUF_FIELD_OFFSET(FarmTools, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FarmTools::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[2]);
}

// ===================================================================

class Vehicle::_Internal {
 public:
};

Vehicle::Vehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.Vehicle)
}
Vehicle::Vehicle(const Vehicle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vehicle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.length_){}
    , decltype(_impl_.over_all_width_){}
    , decltype(_impl_.front_end_to_location_){}
    , decltype(_impl_.rear_end_to_location_){}
    , decltype(_impl_.wheel_base_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.reverse_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.length_, &from._impl_.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reverse_) -
    reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.reverse_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.Vehicle)
}

inline void Vehicle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.length_){0}
    , decltype(_impl_.over_all_width_){0}
    , decltype(_impl_.front_end_to_location_){0}
    , decltype(_impl_.rear_end_to_location_){0}
    , decltype(_impl_.wheel_base_){0}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.reverse_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vehicle::~Vehicle() {
  // @@protoc_insertion_point(destructor:haoxing.route.Vehicle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vehicle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vehicle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vehicle::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.Vehicle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.reverse_) -
      reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.reverse_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vehicle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool reverse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double over_all_width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.over_all_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double front_end_to_location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.front_end_to_location_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rear_end_to_location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.rear_end_to_location_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double wheel_base = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.wheel_base_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double radius = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vehicle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.Vehicle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double length = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_length(), target);
  }

  // bool reverse = 2;
  if (this->_internal_reverse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_reverse(), target);
  }

  // double over_all_width = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_over_all_width = this->_internal_over_all_width();
  uint64_t raw_over_all_width;
  memcpy(&raw_over_all_width, &tmp_over_all_width, sizeof(tmp_over_all_width));
  if (raw_over_all_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_over_all_width(), target);
  }

  // double front_end_to_location = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_front_end_to_location = this->_internal_front_end_to_location();
  uint64_t raw_front_end_to_location;
  memcpy(&raw_front_end_to_location, &tmp_front_end_to_location, sizeof(tmp_front_end_to_location));
  if (raw_front_end_to_location != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_front_end_to_location(), target);
  }

  // double rear_end_to_location = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rear_end_to_location = this->_internal_rear_end_to_location();
  uint64_t raw_rear_end_to_location;
  memcpy(&raw_rear_end_to_location, &tmp_rear_end_to_location, sizeof(tmp_rear_end_to_location));
  if (raw_rear_end_to_location != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_rear_end_to_location(), target);
  }

  // double wheel_base = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_base = this->_internal_wheel_base();
  uint64_t raw_wheel_base;
  memcpy(&raw_wheel_base, &tmp_wheel_base, sizeof(tmp_wheel_base));
  if (raw_wheel_base != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_wheel_base(), target);
  }

  // double radius = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_radius = this->_internal_radius();
  uint64_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.Vehicle)
  return target;
}

size_t Vehicle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.Vehicle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double length = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 1 + 8;
  }

  // double over_all_width = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_over_all_width = this->_internal_over_all_width();
  uint64_t raw_over_all_width;
  memcpy(&raw_over_all_width, &tmp_over_all_width, sizeof(tmp_over_all_width));
  if (raw_over_all_width != 0) {
    total_size += 1 + 8;
  }

  // double front_end_to_location = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_front_end_to_location = this->_internal_front_end_to_location();
  uint64_t raw_front_end_to_location;
  memcpy(&raw_front_end_to_location, &tmp_front_end_to_location, sizeof(tmp_front_end_to_location));
  if (raw_front_end_to_location != 0) {
    total_size += 1 + 8;
  }

  // double rear_end_to_location = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rear_end_to_location = this->_internal_rear_end_to_location();
  uint64_t raw_rear_end_to_location;
  memcpy(&raw_rear_end_to_location, &tmp_rear_end_to_location, sizeof(tmp_rear_end_to_location));
  if (raw_rear_end_to_location != 0) {
    total_size += 1 + 8;
  }

  // double wheel_base = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_base = this->_internal_wheel_base();
  uint64_t raw_wheel_base;
  memcpy(&raw_wheel_base, &tmp_wheel_base, sizeof(tmp_wheel_base));
  if (raw_wheel_base != 0) {
    total_size += 1 + 8;
  }

  // double radius = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_radius = this->_internal_radius();
  uint64_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 1 + 8;
  }

  // bool reverse = 2;
  if (this->_internal_reverse() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vehicle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vehicle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vehicle::GetClassData() const { return &_class_data_; }


void Vehicle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vehicle*>(&to_msg);
  auto& from = static_cast<const Vehicle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.Vehicle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = from._internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_over_all_width = from._internal_over_all_width();
  uint64_t raw_over_all_width;
  memcpy(&raw_over_all_width, &tmp_over_all_width, sizeof(tmp_over_all_width));
  if (raw_over_all_width != 0) {
    _this->_internal_set_over_all_width(from._internal_over_all_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_front_end_to_location = from._internal_front_end_to_location();
  uint64_t raw_front_end_to_location;
  memcpy(&raw_front_end_to_location, &tmp_front_end_to_location, sizeof(tmp_front_end_to_location));
  if (raw_front_end_to_location != 0) {
    _this->_internal_set_front_end_to_location(from._internal_front_end_to_location());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rear_end_to_location = from._internal_rear_end_to_location();
  uint64_t raw_rear_end_to_location;
  memcpy(&raw_rear_end_to_location, &tmp_rear_end_to_location, sizeof(tmp_rear_end_to_location));
  if (raw_rear_end_to_location != 0) {
    _this->_internal_set_rear_end_to_location(from._internal_rear_end_to_location());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_base = from._internal_wheel_base();
  uint64_t raw_wheel_base;
  memcpy(&raw_wheel_base, &tmp_wheel_base, sizeof(tmp_wheel_base));
  if (raw_wheel_base != 0) {
    _this->_internal_set_wheel_base(from._internal_wheel_base());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_radius = from._internal_radius();
  uint64_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  if (from._internal_reverse() != 0) {
    _this->_internal_set_reverse(from._internal_reverse());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vehicle::CopyFrom(const Vehicle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.Vehicle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vehicle::IsInitialized() const {
  return true;
}

void Vehicle::InternalSwap(Vehicle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vehicle, _impl_.reverse_)
      + sizeof(Vehicle::_impl_.reverse_)
      - PROTOBUF_FIELD_OFFSET(Vehicle, _impl_.length_)>(
          reinterpret_cast<char*>(&_impl_.length_),
          reinterpret_cast<char*>(&other->_impl_.length_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vehicle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[3]);
}

// ===================================================================

class ObstacleReq::_Internal {
 public:
};

ObstacleReq::ObstacleReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.ObstacleReq)
}
ObstacleReq::ObstacleReq(const ObstacleReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObstacleReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.r_){}
    , decltype(_impl_.r_w_){}
    , decltype(_impl_.taskindex_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.taskindex_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.taskindex_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.ObstacleReq)
}

inline void ObstacleReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.r_){0}
    , decltype(_impl_.r_w_){0}
    , decltype(_impl_.taskindex_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ObstacleReq::~ObstacleReq() {
  // @@protoc_insertion_point(destructor:haoxing.route.ObstacleReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObstacleReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ObstacleReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObstacleReq::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.ObstacleReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.taskindex_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.taskindex_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObstacleReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double r = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double r_w = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.r_w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 taskIndex = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.taskindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObstacleReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.ObstacleReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double r = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = this->_internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_r(), target);
  }

  // double r_w = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r_w = this->_internal_r_w();
  uint64_t raw_r_w;
  memcpy(&raw_r_w, &tmp_r_w, sizeof(tmp_r_w));
  if (raw_r_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_r_w(), target);
  }

  // int32 taskIndex = 6;
  if (this->_internal_taskindex() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_taskindex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.ObstacleReq)
  return target;
}

size_t ObstacleReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.ObstacleReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double r = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = this->_internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    total_size += 1 + 8;
  }

  // double r_w = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r_w = this->_internal_r_w();
  uint64_t raw_r_w;
  memcpy(&raw_r_w, &tmp_r_w, sizeof(tmp_r_w));
  if (raw_r_w != 0) {
    total_size += 1 + 8;
  }

  // int32 taskIndex = 6;
  if (this->_internal_taskindex() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_taskindex());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObstacleReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObstacleReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObstacleReq::GetClassData() const { return &_class_data_; }


void ObstacleReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObstacleReq*>(&to_msg);
  auto& from = static_cast<const ObstacleReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.ObstacleReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = from._internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r_w = from._internal_r_w();
  uint64_t raw_r_w;
  memcpy(&raw_r_w, &tmp_r_w, sizeof(tmp_r_w));
  if (raw_r_w != 0) {
    _this->_internal_set_r_w(from._internal_r_w());
  }
  if (from._internal_taskindex() != 0) {
    _this->_internal_set_taskindex(from._internal_taskindex());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObstacleReq::CopyFrom(const ObstacleReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.ObstacleReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleReq::IsInitialized() const {
  return true;
}

void ObstacleReq::InternalSwap(ObstacleReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObstacleReq, _impl_.taskindex_)
      + sizeof(ObstacleReq::_impl_.taskindex_)
      - PROTOBUF_FIELD_OFFSET(ObstacleReq, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[4]);
}

// ===================================================================

class PlanParam::_Internal {
 public:
};

PlanParam::PlanParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.PlanParam)
}
PlanParam::PlanParam(const PlanParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.service_nodes_){from._impl_.service_nodes_}
    , decltype(_impl_.linespace_){}
    , decltype(_impl_.interspace_){}
    , decltype(_impl_.safe_distance_){}
    , decltype(_impl_.turn_round_type_){}
    , decltype(_impl_.task_type_){}
    , decltype(_impl_.type_seeding_){}
    , decltype(_impl_.modify_orientation_){}
    , decltype(_impl_.acc_overlap_){}
    , decltype(_impl_.multi_vehicle_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.linespace_, &from._impl_.linespace_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.multi_vehicle_) -
    reinterpret_cast<char*>(&_impl_.linespace_)) + sizeof(_impl_.multi_vehicle_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.PlanParam)
}

inline void PlanParam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.service_nodes_){arena}
    , decltype(_impl_.linespace_){0}
    , decltype(_impl_.interspace_){0}
    , decltype(_impl_.safe_distance_){0}
    , decltype(_impl_.turn_round_type_){0}
    , decltype(_impl_.task_type_){0}
    , decltype(_impl_.type_seeding_){0}
    , decltype(_impl_.modify_orientation_){false}
    , decltype(_impl_.acc_overlap_){false}
    , decltype(_impl_.multi_vehicle_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlanParam::~PlanParam() {
  // @@protoc_insertion_point(destructor:haoxing.route.PlanParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanParam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_nodes_.~RepeatedPtrField();
}

void PlanParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanParam::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.PlanParam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_nodes_.Clear();
  ::memset(&_impl_.linespace_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.multi_vehicle_) -
      reinterpret_cast<char*>(&_impl_.linespace_)) + sizeof(_impl_.multi_vehicle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double lineSpace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.linespace_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double interspace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.interspace_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double safe_distance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.safe_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double turn_round_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.turn_round_type_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double task_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.task_type_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double type_seeding = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.type_seeding_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool modify_orientation = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.modify_orientation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool acc_overlap = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.acc_overlap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool multi_vehicle = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.multi_vehicle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .haoxing.route.NodeXYZ service_nodes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_service_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanParam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.PlanParam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double lineSpace = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_linespace = this->_internal_linespace();
  uint64_t raw_linespace;
  memcpy(&raw_linespace, &tmp_linespace, sizeof(tmp_linespace));
  if (raw_linespace != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_linespace(), target);
  }

  // double interspace = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interspace = this->_internal_interspace();
  uint64_t raw_interspace;
  memcpy(&raw_interspace, &tmp_interspace, sizeof(tmp_interspace));
  if (raw_interspace != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_interspace(), target);
  }

  // double safe_distance = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_distance = this->_internal_safe_distance();
  uint64_t raw_safe_distance;
  memcpy(&raw_safe_distance, &tmp_safe_distance, sizeof(tmp_safe_distance));
  if (raw_safe_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_safe_distance(), target);
  }

  // double turn_round_type = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turn_round_type = this->_internal_turn_round_type();
  uint64_t raw_turn_round_type;
  memcpy(&raw_turn_round_type, &tmp_turn_round_type, sizeof(tmp_turn_round_type));
  if (raw_turn_round_type != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_turn_round_type(), target);
  }

  // double task_type = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_task_type = this->_internal_task_type();
  uint64_t raw_task_type;
  memcpy(&raw_task_type, &tmp_task_type, sizeof(tmp_task_type));
  if (raw_task_type != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_task_type(), target);
  }

  // double type_seeding = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_type_seeding = this->_internal_type_seeding();
  uint64_t raw_type_seeding;
  memcpy(&raw_type_seeding, &tmp_type_seeding, sizeof(tmp_type_seeding));
  if (raw_type_seeding != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_type_seeding(), target);
  }

  // bool modify_orientation = 7;
  if (this->_internal_modify_orientation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_modify_orientation(), target);
  }

  // bool acc_overlap = 8;
  if (this->_internal_acc_overlap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_acc_overlap(), target);
  }

  // bool multi_vehicle = 9;
  if (this->_internal_multi_vehicle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_multi_vehicle(), target);
  }

  // repeated .haoxing.route.NodeXYZ service_nodes = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_service_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_service_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.PlanParam)
  return target;
}

size_t PlanParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.PlanParam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .haoxing.route.NodeXYZ service_nodes = 10;
  total_size += 1UL * this->_internal_service_nodes_size();
  for (const auto& msg : this->_impl_.service_nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // double lineSpace = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_linespace = this->_internal_linespace();
  uint64_t raw_linespace;
  memcpy(&raw_linespace, &tmp_linespace, sizeof(tmp_linespace));
  if (raw_linespace != 0) {
    total_size += 1 + 8;
  }

  // double interspace = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interspace = this->_internal_interspace();
  uint64_t raw_interspace;
  memcpy(&raw_interspace, &tmp_interspace, sizeof(tmp_interspace));
  if (raw_interspace != 0) {
    total_size += 1 + 8;
  }

  // double safe_distance = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_distance = this->_internal_safe_distance();
  uint64_t raw_safe_distance;
  memcpy(&raw_safe_distance, &tmp_safe_distance, sizeof(tmp_safe_distance));
  if (raw_safe_distance != 0) {
    total_size += 1 + 8;
  }

  // double turn_round_type = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turn_round_type = this->_internal_turn_round_type();
  uint64_t raw_turn_round_type;
  memcpy(&raw_turn_round_type, &tmp_turn_round_type, sizeof(tmp_turn_round_type));
  if (raw_turn_round_type != 0) {
    total_size += 1 + 8;
  }

  // double task_type = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_task_type = this->_internal_task_type();
  uint64_t raw_task_type;
  memcpy(&raw_task_type, &tmp_task_type, sizeof(tmp_task_type));
  if (raw_task_type != 0) {
    total_size += 1 + 8;
  }

  // double type_seeding = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_type_seeding = this->_internal_type_seeding();
  uint64_t raw_type_seeding;
  memcpy(&raw_type_seeding, &tmp_type_seeding, sizeof(tmp_type_seeding));
  if (raw_type_seeding != 0) {
    total_size += 1 + 8;
  }

  // bool modify_orientation = 7;
  if (this->_internal_modify_orientation() != 0) {
    total_size += 1 + 1;
  }

  // bool acc_overlap = 8;
  if (this->_internal_acc_overlap() != 0) {
    total_size += 1 + 1;
  }

  // bool multi_vehicle = 9;
  if (this->_internal_multi_vehicle() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanParam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanParam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanParam::GetClassData() const { return &_class_data_; }


void PlanParam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanParam*>(&to_msg);
  auto& from = static_cast<const PlanParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.PlanParam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.service_nodes_.MergeFrom(from._impl_.service_nodes_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_linespace = from._internal_linespace();
  uint64_t raw_linespace;
  memcpy(&raw_linespace, &tmp_linespace, sizeof(tmp_linespace));
  if (raw_linespace != 0) {
    _this->_internal_set_linespace(from._internal_linespace());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interspace = from._internal_interspace();
  uint64_t raw_interspace;
  memcpy(&raw_interspace, &tmp_interspace, sizeof(tmp_interspace));
  if (raw_interspace != 0) {
    _this->_internal_set_interspace(from._internal_interspace());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_distance = from._internal_safe_distance();
  uint64_t raw_safe_distance;
  memcpy(&raw_safe_distance, &tmp_safe_distance, sizeof(tmp_safe_distance));
  if (raw_safe_distance != 0) {
    _this->_internal_set_safe_distance(from._internal_safe_distance());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turn_round_type = from._internal_turn_round_type();
  uint64_t raw_turn_round_type;
  memcpy(&raw_turn_round_type, &tmp_turn_round_type, sizeof(tmp_turn_round_type));
  if (raw_turn_round_type != 0) {
    _this->_internal_set_turn_round_type(from._internal_turn_round_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_task_type = from._internal_task_type();
  uint64_t raw_task_type;
  memcpy(&raw_task_type, &tmp_task_type, sizeof(tmp_task_type));
  if (raw_task_type != 0) {
    _this->_internal_set_task_type(from._internal_task_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_type_seeding = from._internal_type_seeding();
  uint64_t raw_type_seeding;
  memcpy(&raw_type_seeding, &tmp_type_seeding, sizeof(tmp_type_seeding));
  if (raw_type_seeding != 0) {
    _this->_internal_set_type_seeding(from._internal_type_seeding());
  }
  if (from._internal_modify_orientation() != 0) {
    _this->_internal_set_modify_orientation(from._internal_modify_orientation());
  }
  if (from._internal_acc_overlap() != 0) {
    _this->_internal_set_acc_overlap(from._internal_acc_overlap());
  }
  if (from._internal_multi_vehicle() != 0) {
    _this->_internal_set_multi_vehicle(from._internal_multi_vehicle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanParam::CopyFrom(const PlanParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.PlanParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanParam::IsInitialized() const {
  return true;
}

void PlanParam::InternalSwap(PlanParam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.service_nodes_.InternalSwap(&other->_impl_.service_nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanParam, _impl_.multi_vehicle_)
      + sizeof(PlanParam::_impl_.multi_vehicle_)
      - PROTOBUF_FIELD_OFFSET(PlanParam, _impl_.linespace_)>(
          reinterpret_cast<char*>(&_impl_.linespace_),
          reinterpret_cast<char*>(&other->_impl_.linespace_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[5]);
}

// ===================================================================

class RoadPlanRequest::_Internal {
 public:
  static const ::haoxing::route::GisFieldInfo& gisfieldinfo(const RoadPlanRequest* msg);
  static const ::haoxing::route::FarmTools& farmtools(const RoadPlanRequest* msg);
  static const ::haoxing::route::Vehicle& vehicle(const RoadPlanRequest* msg);
  static const ::haoxing::route::PlanParam& planparam(const RoadPlanRequest* msg);
};

const ::haoxing::route::GisFieldInfo&
RoadPlanRequest::_Internal::gisfieldinfo(const RoadPlanRequest* msg) {
  return *msg->_impl_.gisfieldinfo_;
}
const ::haoxing::route::FarmTools&
RoadPlanRequest::_Internal::farmtools(const RoadPlanRequest* msg) {
  return *msg->_impl_.farmtools_;
}
const ::haoxing::route::Vehicle&
RoadPlanRequest::_Internal::vehicle(const RoadPlanRequest* msg) {
  return *msg->_impl_.vehicle_;
}
const ::haoxing::route::PlanParam&
RoadPlanRequest::_Internal::planparam(const RoadPlanRequest* msg) {
  return *msg->_impl_.planparam_;
}
RoadPlanRequest::RoadPlanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.RoadPlanRequest)
}
RoadPlanRequest::RoadPlanRequest(const RoadPlanRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RoadPlanRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gisfieldinfo_){nullptr}
    , decltype(_impl_.farmtools_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.planparam_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_gisfieldinfo()) {
    _this->_impl_.gisfieldinfo_ = new ::haoxing::route::GisFieldInfo(*from._impl_.gisfieldinfo_);
  }
  if (from._internal_has_farmtools()) {
    _this->_impl_.farmtools_ = new ::haoxing::route::FarmTools(*from._impl_.farmtools_);
  }
  if (from._internal_has_vehicle()) {
    _this->_impl_.vehicle_ = new ::haoxing::route::Vehicle(*from._impl_.vehicle_);
  }
  if (from._internal_has_planparam()) {
    _this->_impl_.planparam_ = new ::haoxing::route::PlanParam(*from._impl_.planparam_);
  }
  // @@protoc_insertion_point(copy_constructor:haoxing.route.RoadPlanRequest)
}

inline void RoadPlanRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gisfieldinfo_){nullptr}
    , decltype(_impl_.farmtools_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.planparam_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RoadPlanRequest::~RoadPlanRequest() {
  // @@protoc_insertion_point(destructor:haoxing.route.RoadPlanRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoadPlanRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.gisfieldinfo_;
  if (this != internal_default_instance()) delete _impl_.farmtools_;
  if (this != internal_default_instance()) delete _impl_.vehicle_;
  if (this != internal_default_instance()) delete _impl_.planparam_;
}

void RoadPlanRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RoadPlanRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.RoadPlanRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.gisfieldinfo_ != nullptr) {
    delete _impl_.gisfieldinfo_;
  }
  _impl_.gisfieldinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.farmtools_ != nullptr) {
    delete _impl_.farmtools_;
  }
  _impl_.farmtools_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.planparam_ != nullptr) {
    delete _impl_.planparam_;
  }
  _impl_.planparam_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RoadPlanRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .haoxing.route.GisFieldInfo gisFieldInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_gisfieldinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.FarmTools farmTools = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_farmtools(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.Vehicle vehicle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_vehicle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.PlanParam planParam = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_planparam(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoadPlanRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.RoadPlanRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .haoxing.route.GisFieldInfo gisFieldInfo = 1;
  if (this->_internal_has_gisfieldinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::gisfieldinfo(this),
        _Internal::gisfieldinfo(this).GetCachedSize(), target, stream);
  }

  // .haoxing.route.FarmTools farmTools = 2;
  if (this->_internal_has_farmtools()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::farmtools(this),
        _Internal::farmtools(this).GetCachedSize(), target, stream);
  }

  // .haoxing.route.Vehicle vehicle = 3;
  if (this->_internal_has_vehicle()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::vehicle(this),
        _Internal::vehicle(this).GetCachedSize(), target, stream);
  }

  // .haoxing.route.PlanParam planParam = 4;
  if (this->_internal_has_planparam()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::planparam(this),
        _Internal::planparam(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.RoadPlanRequest)
  return target;
}

size_t RoadPlanRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.RoadPlanRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .haoxing.route.GisFieldInfo gisFieldInfo = 1;
  if (this->_internal_has_gisfieldinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.gisfieldinfo_);
  }

  // .haoxing.route.FarmTools farmTools = 2;
  if (this->_internal_has_farmtools()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.farmtools_);
  }

  // .haoxing.route.Vehicle vehicle = 3;
  if (this->_internal_has_vehicle()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vehicle_);
  }

  // .haoxing.route.PlanParam planParam = 4;
  if (this->_internal_has_planparam()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.planparam_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RoadPlanRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RoadPlanRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RoadPlanRequest::GetClassData() const { return &_class_data_; }


void RoadPlanRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RoadPlanRequest*>(&to_msg);
  auto& from = static_cast<const RoadPlanRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.RoadPlanRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gisfieldinfo()) {
    _this->_internal_mutable_gisfieldinfo()->::haoxing::route::GisFieldInfo::MergeFrom(
        from._internal_gisfieldinfo());
  }
  if (from._internal_has_farmtools()) {
    _this->_internal_mutable_farmtools()->::haoxing::route::FarmTools::MergeFrom(
        from._internal_farmtools());
  }
  if (from._internal_has_vehicle()) {
    _this->_internal_mutable_vehicle()->::haoxing::route::Vehicle::MergeFrom(
        from._internal_vehicle());
  }
  if (from._internal_has_planparam()) {
    _this->_internal_mutable_planparam()->::haoxing::route::PlanParam::MergeFrom(
        from._internal_planparam());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RoadPlanRequest::CopyFrom(const RoadPlanRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.RoadPlanRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadPlanRequest::IsInitialized() const {
  return true;
}

void RoadPlanRequest::InternalSwap(RoadPlanRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RoadPlanRequest, _impl_.planparam_)
      + sizeof(RoadPlanRequest::_impl_.planparam_)
      - PROTOBUF_FIELD_OFFSET(RoadPlanRequest, _impl_.gisfieldinfo_)>(
          reinterpret_cast<char*>(&_impl_.gisfieldinfo_),
          reinterpret_cast<char*>(&other->_impl_.gisfieldinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RoadPlanRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[6]);
}

// ===================================================================

class RoadPlanRespond::_Internal {
 public:
};

RoadPlanRespond::RoadPlanRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.RoadPlanRespond)
}
RoadPlanRespond::RoadPlanRespond(const RoadPlanRespond& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RoadPlanRespond* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , decltype(_impl_.mileage_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.mileage_ = from._impl_.mileage_;
  // @@protoc_insertion_point(copy_constructor:haoxing.route.RoadPlanRespond)
}

inline void RoadPlanRespond::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , decltype(_impl_.mileage_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RoadPlanRespond::~RoadPlanRespond() {
  // @@protoc_insertion_point(destructor:haoxing.route.RoadPlanRespond)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoadPlanRespond::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void RoadPlanRespond::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RoadPlanRespond::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.RoadPlanRespond)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _impl_.mileage_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RoadPlanRespond::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .haoxing.route.NodeXYZ nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double mileage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.mileage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoadPlanRespond::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.RoadPlanRespond)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .haoxing.route.NodeXYZ nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // double mileage = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mileage = this->_internal_mileage();
  uint64_t raw_mileage;
  memcpy(&raw_mileage, &tmp_mileage, sizeof(tmp_mileage));
  if (raw_mileage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_mileage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.RoadPlanRespond)
  return target;
}

size_t RoadPlanRespond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.RoadPlanRespond)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .haoxing.route.NodeXYZ nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // double mileage = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mileage = this->_internal_mileage();
  uint64_t raw_mileage;
  memcpy(&raw_mileage, &tmp_mileage, sizeof(tmp_mileage));
  if (raw_mileage != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RoadPlanRespond::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RoadPlanRespond::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RoadPlanRespond::GetClassData() const { return &_class_data_; }


void RoadPlanRespond::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RoadPlanRespond*>(&to_msg);
  auto& from = static_cast<const RoadPlanRespond&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.RoadPlanRespond)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mileage = from._internal_mileage();
  uint64_t raw_mileage;
  memcpy(&raw_mileage, &tmp_mileage, sizeof(tmp_mileage));
  if (raw_mileage != 0) {
    _this->_internal_set_mileage(from._internal_mileage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RoadPlanRespond::CopyFrom(const RoadPlanRespond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.RoadPlanRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadPlanRespond::IsInitialized() const {
  return true;
}

void RoadPlanRespond::InternalSwap(RoadPlanRespond* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  swap(_impl_.mileage_, other->_impl_.mileage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RoadPlanRespond::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace route
}  // namespace haoxing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::haoxing::route::NodeXYZ*
Arena::CreateMaybeMessage< ::haoxing::route::NodeXYZ >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::NodeXYZ >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::GisFieldInfo*
Arena::CreateMaybeMessage< ::haoxing::route::GisFieldInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::GisFieldInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::FarmTools*
Arena::CreateMaybeMessage< ::haoxing::route::FarmTools >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::FarmTools >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::Vehicle*
Arena::CreateMaybeMessage< ::haoxing::route::Vehicle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::Vehicle >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::ObstacleReq*
Arena::CreateMaybeMessage< ::haoxing::route::ObstacleReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::ObstacleReq >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::PlanParam*
Arena::CreateMaybeMessage< ::haoxing::route::PlanParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::PlanParam >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::RoadPlanRequest*
Arena::CreateMaybeMessage< ::haoxing::route::RoadPlanRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::RoadPlanRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::RoadPlanRespond*
Arena::CreateMaybeMessage< ::haoxing::route::RoadPlanRespond >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::RoadPlanRespond >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
