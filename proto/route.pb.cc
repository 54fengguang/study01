// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#include "route.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace haoxing {
namespace route {
PROTOBUF_CONSTEXPR NodeXYZ::NodeXYZ(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.yaw_)*/0
  , /*decltype(_impl_.curvature_)*/0
  , /*decltype(_impl_.segment_)*/0
  , /*decltype(_impl_.reverse_)*/false
  , /*decltype(_impl_.node_type_)*/0
  , /*decltype(_impl_.impl_state_)*/0
  , /*decltype(_impl_.impl_plough_ori_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeXYZDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeXYZDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeXYZDefaultTypeInternal() {}
  union {
    NodeXYZ _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeXYZDefaultTypeInternal _NodeXYZ_default_instance_;
PROTOBUF_CONSTEXPR FieldInfo::FieldInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fieldnodes_)*/{}
  , /*decltype(_impl_.obstacles_)*/{}
  , /*decltype(_impl_.preset_spaces_)*/{}
  , /*decltype(_impl_.entrance_node_)*/nullptr
  , /*decltype(_impl_.exit_node_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FieldInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldInfoDefaultTypeInternal() {}
  union {
    FieldInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldInfoDefaultTypeInternal _FieldInfo_default_instance_;
PROTOBUF_CONSTEXPR PlanParam::PlanParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.task_vehicle_num_)*/{}
  , /*decltype(_impl_._task_vehicle_num_cached_byte_size_)*/{0}
  , /*decltype(_impl_.service_nodes_)*/{}
  , /*decltype(_impl_.inter_sp_)*/0
  , /*decltype(_impl_.route_type_)*/0
  , /*decltype(_impl_.task_type_)*/0
  , /*decltype(_impl_.modify_orientation_)*/false
  , /*decltype(_impl_.acc_overlap_)*/false
  , /*decltype(_impl_.multi_vehicle_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlanParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanParamDefaultTypeInternal() {}
  union {
    PlanParam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanParamDefaultTypeInternal _PlanParam_default_instance_;
PROTOBUF_CONSTEXPR Vehicle::Vehicle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.length_)*/0
  , /*decltype(_impl_.over_all_width_)*/0
  , /*decltype(_impl_.front_end_to_location_)*/0
  , /*decltype(_impl_.rear_end_to_location_)*/0
  , /*decltype(_impl_.wheel_base_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.reverse_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VehicleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VehicleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VehicleDefaultTypeInternal() {}
  union {
    Vehicle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VehicleDefaultTypeInternal _Vehicle_default_instance_;
PROTOBUF_CONSTEXPR Implement::Implement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.length_)*/0
  , /*decltype(_impl_.right_offset_)*/0
  , /*decltype(_impl_.left_offset_)*/0
  , /*decltype(_impl_.linkage_mode_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ImplementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImplementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImplementDefaultTypeInternal() {}
  union {
    Implement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImplementDefaultTypeInternal _Implement_default_instance_;
PROTOBUF_CONSTEXPR Obstacle::Obstacle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.r_)*/0
  , /*decltype(_impl_.r_w_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ObstacleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObstacleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObstacleDefaultTypeInternal() {}
  union {
    Obstacle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObstacleDefaultTypeInternal _Obstacle_default_instance_;
PROTOBUF_CONSTEXPR RequestParam::RequestParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.field_infos_)*/{}
  , /*decltype(_impl_.plan_param_)*/nullptr
  , /*decltype(_impl_.vehicle_)*/nullptr
  , /*decltype(_impl_.implement_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestParamDefaultTypeInternal() {}
  union {
    RequestParam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestParamDefaultTypeInternal _RequestParam_default_instance_;
PROTOBUF_CONSTEXPR ResponseParam::ResponseParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_.mileage_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseParamDefaultTypeInternal() {}
  union {
    ResponseParam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseParamDefaultTypeInternal _ResponseParam_default_instance_;
}  // namespace route
}  // namespace haoxing
static ::_pb::Metadata file_level_metadata_route_2eproto[8];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_route_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_route_2eproto = nullptr;

const uint32_t TableStruct_route_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.yaw_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.curvature_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.segment_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.reverse_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.node_type_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.impl_state_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::NodeXYZ, _impl_.impl_plough_ori_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FieldInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FieldInfo, _impl_.entrance_node_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FieldInfo, _impl_.exit_node_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FieldInfo, _impl_.fieldnodes_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FieldInfo, _impl_.obstacles_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::FieldInfo, _impl_.preset_spaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.inter_sp_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.route_type_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.task_type_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.modify_orientation_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.acc_overlap_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.multi_vehicle_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.task_vehicle_num_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::PlanParam, _impl_.service_nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.reverse_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.over_all_width_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.front_end_to_location_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.rear_end_to_location_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.wheel_base_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Vehicle, _impl_.radius_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Implement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Implement, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Implement, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Implement, _impl_.right_offset_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Implement, _impl_.left_offset_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Implement, _impl_.linkage_mode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Obstacle, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Obstacle, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Obstacle, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Obstacle, _impl_.r_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::Obstacle, _impl_.r_w_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RequestParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RequestParam, _impl_.field_infos_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RequestParam, _impl_.plan_param_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RequestParam, _impl_.vehicle_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::RequestParam, _impl_.implement_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ResponseParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ResponseParam, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::haoxing::route::ResponseParam, _impl_.mileage_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::haoxing::route::NodeXYZ)},
  { 16, -1, -1, sizeof(::haoxing::route::FieldInfo)},
  { 27, -1, -1, sizeof(::haoxing::route::PlanParam)},
  { 41, -1, -1, sizeof(::haoxing::route::Vehicle)},
  { 54, -1, -1, sizeof(::haoxing::route::Implement)},
  { 65, -1, -1, sizeof(::haoxing::route::Obstacle)},
  { 76, -1, -1, sizeof(::haoxing::route::RequestParam)},
  { 86, -1, -1, sizeof(::haoxing::route::ResponseParam)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::haoxing::route::_NodeXYZ_default_instance_._instance,
  &::haoxing::route::_FieldInfo_default_instance_._instance,
  &::haoxing::route::_PlanParam_default_instance_._instance,
  &::haoxing::route::_Vehicle_default_instance_._instance,
  &::haoxing::route::_Implement_default_instance_._instance,
  &::haoxing::route::_Obstacle_default_instance_._instance,
  &::haoxing::route::_RequestParam_default_instance_._instance,
  &::haoxing::route::_ResponseParam_default_instance_._instance,
};

const char descriptor_table_protodef_route_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013route.proto\022\rhaoxing.route\"\254\001\n\007NodeXYZ"
  "\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\013\n\003yaw"
  "\030\004 \001(\001\022\021\n\tcurvature\030\005 \001(\001\022\017\n\007segment\030\006 \001"
  "(\005\022\017\n\007reverse\030\007 \001(\010\022\021\n\tnode_type\030\010 \001(\005\022\022"
  "\n\nimpl_state\030\t \001(\005\022\027\n\017impl_plough_ori\030\n "
  "\001(\005\"\324\001\n\tFieldInfo\022-\n\rentrance_node\030\001 \001(\013"
  "2\026.haoxing.route.NodeXYZ\022)\n\texit_node\030\002 "
  "\001(\0132\026.haoxing.route.NodeXYZ\022*\n\nfieldNode"
  "s\030\003 \003(\0132\026.haoxing.route.NodeXYZ\022*\n\tobsta"
  "cles\030\004 \003(\0132\027.haoxing.route.Obstacle\022\025\n\rp"
  "reset_spaces\030\005 \003(\001\"\325\001\n\tPlanParam\022\020\n\010inte"
  "r_sp\030\001 \001(\001\022\022\n\nroute_type\030\002 \001(\001\022\021\n\ttask_t"
  "ype\030\003 \001(\001\022\032\n\022modify_orientation\030\004 \001(\010\022\023\n"
  "\013acc_overlap\030\005 \001(\010\022\025\n\rmulti_vehicle\030\006 \001("
  "\010\022\030\n\020task_vehicle_num\030\007 \003(\005\022-\n\rservice_n"
  "odes\030\010 \003(\0132\026.haoxing.route.NodeXYZ\"\243\001\n\007V"
  "ehicle\022\016\n\006length\030\001 \001(\001\022\017\n\007reverse\030\002 \001(\010\022"
  "\026\n\016over_all_width\030\003 \001(\001\022\035\n\025front_end_to_"
  "location\030\004 \001(\001\022\034\n\024rear_end_to_location\030\005"
  " \001(\001\022\022\n\nwheel_base\030\006 \001(\001\022\016\n\006radius\030\007 \001(\001"
  "\"k\n\tImplement\022\r\n\005width\030\001 \001(\001\022\016\n\006length\030\002"
  " \001(\001\022\024\n\014right_offset\030\003 \001(\001\022\023\n\013left_offse"
  "t\030\004 \001(\001\022\024\n\014linkage_mode\030\005 \001(\005\"C\n\010Obstacl"
  "e\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\t\n\001r\030"
  "\004 \001(\001\022\013\n\003r_w\030\005 \001(\001\"\301\001\n\014RequestParam\022-\n\013f"
  "ield_infos\030\001 \003(\0132\030.haoxing.route.FieldIn"
  "fo\022,\n\nplan_param\030\002 \001(\0132\030.haoxing.route.P"
  "lanParam\022\'\n\007vehicle\030\003 \001(\0132\026.haoxing.rout"
  "e.Vehicle\022+\n\timplement\030\004 \001(\0132\030.haoxing.r"
  "oute.Implement\"G\n\rResponseParam\022%\n\005nodes"
  "\030\001 \003(\0132\026.haoxing.route.NodeXYZ\022\017\n\007mileag"
  "e\030\002 \001(\0012_\n\016RoutingService\022M\n\016GetNodeXYZL"
  "ist\022\033.haoxing.route.RequestParam\032\034.haoxi"
  "ng.route.ResponseParam\"\000B7\n\036com.hx.sched"
  "ule.algorithm.grpcB\014RoutingProtoP\001\242\002\004hxk"
  "jb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_route_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_route_2eproto = {
    false, false, 1409, descriptor_table_protodef_route_2eproto,
    "route.proto",
    &descriptor_table_route_2eproto_once, nullptr, 0, 8,
    schemas, file_default_instances, TableStruct_route_2eproto::offsets,
    file_level_metadata_route_2eproto, file_level_enum_descriptors_route_2eproto,
    file_level_service_descriptors_route_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_route_2eproto_getter() {
  return &descriptor_table_route_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_route_2eproto(&descriptor_table_route_2eproto);
namespace haoxing {
namespace route {

// ===================================================================

class NodeXYZ::_Internal {
 public:
};

NodeXYZ::NodeXYZ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.NodeXYZ)
}
NodeXYZ::NodeXYZ(const NodeXYZ& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeXYZ* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.yaw_){}
    , decltype(_impl_.curvature_){}
    , decltype(_impl_.segment_){}
    , decltype(_impl_.reverse_){}
    , decltype(_impl_.node_type_){}
    , decltype(_impl_.impl_state_){}
    , decltype(_impl_.impl_plough_ori_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.impl_plough_ori_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.impl_plough_ori_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.NodeXYZ)
}

inline void NodeXYZ::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.yaw_){0}
    , decltype(_impl_.curvature_){0}
    , decltype(_impl_.segment_){0}
    , decltype(_impl_.reverse_){false}
    , decltype(_impl_.node_type_){0}
    , decltype(_impl_.impl_state_){0}
    , decltype(_impl_.impl_plough_ori_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodeXYZ::~NodeXYZ() {
  // @@protoc_insertion_point(destructor:haoxing.route.NodeXYZ)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeXYZ::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NodeXYZ::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeXYZ::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.NodeXYZ)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.impl_plough_ori_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.impl_plough_ori_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeXYZ::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double yaw = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double curvature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.curvature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 segment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.segment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reverse = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 node_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.node_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 impl_state = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.impl_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 impl_plough_ori = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.impl_plough_ori_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeXYZ::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.NodeXYZ)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double yaw = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_yaw(), target);
  }

  // double curvature = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curvature = this->_internal_curvature();
  uint64_t raw_curvature;
  memcpy(&raw_curvature, &tmp_curvature, sizeof(tmp_curvature));
  if (raw_curvature != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_curvature(), target);
  }

  // int32 segment = 6;
  if (this->_internal_segment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_segment(), target);
  }

  // bool reverse = 7;
  if (this->_internal_reverse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_reverse(), target);
  }

  // int32 node_type = 8;
  if (this->_internal_node_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_node_type(), target);
  }

  // int32 impl_state = 9;
  if (this->_internal_impl_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_impl_state(), target);
  }

  // int32 impl_plough_ori = 10;
  if (this->_internal_impl_plough_ori() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_impl_plough_ori(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.NodeXYZ)
  return target;
}

size_t NodeXYZ::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.NodeXYZ)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double yaw = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 1 + 8;
  }

  // double curvature = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curvature = this->_internal_curvature();
  uint64_t raw_curvature;
  memcpy(&raw_curvature, &tmp_curvature, sizeof(tmp_curvature));
  if (raw_curvature != 0) {
    total_size += 1 + 8;
  }

  // int32 segment = 6;
  if (this->_internal_segment() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_segment());
  }

  // bool reverse = 7;
  if (this->_internal_reverse() != 0) {
    total_size += 1 + 1;
  }

  // int32 node_type = 8;
  if (this->_internal_node_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_node_type());
  }

  // int32 impl_state = 9;
  if (this->_internal_impl_state() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_impl_state());
  }

  // int32 impl_plough_ori = 10;
  if (this->_internal_impl_plough_ori() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_impl_plough_ori());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeXYZ::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeXYZ::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeXYZ::GetClassData() const { return &_class_data_; }


void NodeXYZ::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeXYZ*>(&to_msg);
  auto& from = static_cast<const NodeXYZ&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.NodeXYZ)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_yaw = from._internal_yaw();
  uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curvature = from._internal_curvature();
  uint64_t raw_curvature;
  memcpy(&raw_curvature, &tmp_curvature, sizeof(tmp_curvature));
  if (raw_curvature != 0) {
    _this->_internal_set_curvature(from._internal_curvature());
  }
  if (from._internal_segment() != 0) {
    _this->_internal_set_segment(from._internal_segment());
  }
  if (from._internal_reverse() != 0) {
    _this->_internal_set_reverse(from._internal_reverse());
  }
  if (from._internal_node_type() != 0) {
    _this->_internal_set_node_type(from._internal_node_type());
  }
  if (from._internal_impl_state() != 0) {
    _this->_internal_set_impl_state(from._internal_impl_state());
  }
  if (from._internal_impl_plough_ori() != 0) {
    _this->_internal_set_impl_plough_ori(from._internal_impl_plough_ori());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeXYZ::CopyFrom(const NodeXYZ& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.NodeXYZ)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeXYZ::IsInitialized() const {
  return true;
}

void NodeXYZ::InternalSwap(NodeXYZ* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeXYZ, _impl_.impl_plough_ori_)
      + sizeof(NodeXYZ::_impl_.impl_plough_ori_)
      - PROTOBUF_FIELD_OFFSET(NodeXYZ, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeXYZ::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[0]);
}

// ===================================================================

class FieldInfo::_Internal {
 public:
  static const ::haoxing::route::NodeXYZ& entrance_node(const FieldInfo* msg);
  static const ::haoxing::route::NodeXYZ& exit_node(const FieldInfo* msg);
};

const ::haoxing::route::NodeXYZ&
FieldInfo::_Internal::entrance_node(const FieldInfo* msg) {
  return *msg->_impl_.entrance_node_;
}
const ::haoxing::route::NodeXYZ&
FieldInfo::_Internal::exit_node(const FieldInfo* msg) {
  return *msg->_impl_.exit_node_;
}
FieldInfo::FieldInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.FieldInfo)
}
FieldInfo::FieldInfo(const FieldInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FieldInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fieldnodes_){from._impl_.fieldnodes_}
    , decltype(_impl_.obstacles_){from._impl_.obstacles_}
    , decltype(_impl_.preset_spaces_){from._impl_.preset_spaces_}
    , decltype(_impl_.entrance_node_){nullptr}
    , decltype(_impl_.exit_node_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_entrance_node()) {
    _this->_impl_.entrance_node_ = new ::haoxing::route::NodeXYZ(*from._impl_.entrance_node_);
  }
  if (from._internal_has_exit_node()) {
    _this->_impl_.exit_node_ = new ::haoxing::route::NodeXYZ(*from._impl_.exit_node_);
  }
  // @@protoc_insertion_point(copy_constructor:haoxing.route.FieldInfo)
}

inline void FieldInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fieldnodes_){arena}
    , decltype(_impl_.obstacles_){arena}
    , decltype(_impl_.preset_spaces_){arena}
    , decltype(_impl_.entrance_node_){nullptr}
    , decltype(_impl_.exit_node_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FieldInfo::~FieldInfo() {
  // @@protoc_insertion_point(destructor:haoxing.route.FieldInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FieldInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fieldnodes_.~RepeatedPtrField();
  _impl_.obstacles_.~RepeatedPtrField();
  _impl_.preset_spaces_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.entrance_node_;
  if (this != internal_default_instance()) delete _impl_.exit_node_;
}

void FieldInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FieldInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.FieldInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fieldnodes_.Clear();
  _impl_.obstacles_.Clear();
  _impl_.preset_spaces_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.entrance_node_ != nullptr) {
    delete _impl_.entrance_node_;
  }
  _impl_.entrance_node_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.exit_node_ != nullptr) {
    delete _impl_.exit_node_;
  }
  _impl_.exit_node_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .haoxing.route.NodeXYZ entrance_node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_entrance_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.NodeXYZ exit_node = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_exit_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fieldnodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .haoxing.route.Obstacle obstacles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_obstacles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double preset_spaces = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_preset_spaces(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 41) {
          _internal_add_preset_spaces(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FieldInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.FieldInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .haoxing.route.NodeXYZ entrance_node = 1;
  if (this->_internal_has_entrance_node()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::entrance_node(this),
        _Internal::entrance_node(this).GetCachedSize(), target, stream);
  }

  // .haoxing.route.NodeXYZ exit_node = 2;
  if (this->_internal_has_exit_node()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::exit_node(this),
        _Internal::exit_node(this).GetCachedSize(), target, stream);
  }

  // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fieldnodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_fieldnodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .haoxing.route.Obstacle obstacles = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_obstacles_size()); i < n; i++) {
    const auto& repfield = this->_internal_obstacles(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated double preset_spaces = 5;
  if (this->_internal_preset_spaces_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_preset_spaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.FieldInfo)
  return target;
}

size_t FieldInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.FieldInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .haoxing.route.NodeXYZ fieldNodes = 3;
  total_size += 1UL * this->_internal_fieldnodes_size();
  for (const auto& msg : this->_impl_.fieldnodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .haoxing.route.Obstacle obstacles = 4;
  total_size += 1UL * this->_internal_obstacles_size();
  for (const auto& msg : this->_impl_.obstacles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double preset_spaces = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_preset_spaces_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .haoxing.route.NodeXYZ entrance_node = 1;
  if (this->_internal_has_entrance_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.entrance_node_);
  }

  // .haoxing.route.NodeXYZ exit_node = 2;
  if (this->_internal_has_exit_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.exit_node_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FieldInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FieldInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FieldInfo::GetClassData() const { return &_class_data_; }


void FieldInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FieldInfo*>(&to_msg);
  auto& from = static_cast<const FieldInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.FieldInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fieldnodes_.MergeFrom(from._impl_.fieldnodes_);
  _this->_impl_.obstacles_.MergeFrom(from._impl_.obstacles_);
  _this->_impl_.preset_spaces_.MergeFrom(from._impl_.preset_spaces_);
  if (from._internal_has_entrance_node()) {
    _this->_internal_mutable_entrance_node()->::haoxing::route::NodeXYZ::MergeFrom(
        from._internal_entrance_node());
  }
  if (from._internal_has_exit_node()) {
    _this->_internal_mutable_exit_node()->::haoxing::route::NodeXYZ::MergeFrom(
        from._internal_exit_node());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FieldInfo::CopyFrom(const FieldInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.FieldInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldInfo::IsInitialized() const {
  return true;
}

void FieldInfo::InternalSwap(FieldInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fieldnodes_.InternalSwap(&other->_impl_.fieldnodes_);
  _impl_.obstacles_.InternalSwap(&other->_impl_.obstacles_);
  _impl_.preset_spaces_.InternalSwap(&other->_impl_.preset_spaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FieldInfo, _impl_.exit_node_)
      + sizeof(FieldInfo::_impl_.exit_node_)
      - PROTOBUF_FIELD_OFFSET(FieldInfo, _impl_.entrance_node_)>(
          reinterpret_cast<char*>(&_impl_.entrance_node_),
          reinterpret_cast<char*>(&other->_impl_.entrance_node_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[1]);
}

// ===================================================================

class PlanParam::_Internal {
 public:
};

PlanParam::PlanParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.PlanParam)
}
PlanParam::PlanParam(const PlanParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.task_vehicle_num_){from._impl_.task_vehicle_num_}
    , /*decltype(_impl_._task_vehicle_num_cached_byte_size_)*/{0}
    , decltype(_impl_.service_nodes_){from._impl_.service_nodes_}
    , decltype(_impl_.inter_sp_){}
    , decltype(_impl_.route_type_){}
    , decltype(_impl_.task_type_){}
    , decltype(_impl_.modify_orientation_){}
    , decltype(_impl_.acc_overlap_){}
    , decltype(_impl_.multi_vehicle_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.inter_sp_, &from._impl_.inter_sp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.multi_vehicle_) -
    reinterpret_cast<char*>(&_impl_.inter_sp_)) + sizeof(_impl_.multi_vehicle_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.PlanParam)
}

inline void PlanParam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.task_vehicle_num_){arena}
    , /*decltype(_impl_._task_vehicle_num_cached_byte_size_)*/{0}
    , decltype(_impl_.service_nodes_){arena}
    , decltype(_impl_.inter_sp_){0}
    , decltype(_impl_.route_type_){0}
    , decltype(_impl_.task_type_){0}
    , decltype(_impl_.modify_orientation_){false}
    , decltype(_impl_.acc_overlap_){false}
    , decltype(_impl_.multi_vehicle_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlanParam::~PlanParam() {
  // @@protoc_insertion_point(destructor:haoxing.route.PlanParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanParam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.task_vehicle_num_.~RepeatedField();
  _impl_.service_nodes_.~RepeatedPtrField();
}

void PlanParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanParam::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.PlanParam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.task_vehicle_num_.Clear();
  _impl_.service_nodes_.Clear();
  ::memset(&_impl_.inter_sp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.multi_vehicle_) -
      reinterpret_cast<char*>(&_impl_.inter_sp_)) + sizeof(_impl_.multi_vehicle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double inter_sp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.inter_sp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double route_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.route_type_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double task_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.task_type_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool modify_orientation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.modify_orientation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool acc_overlap = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.acc_overlap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool multi_vehicle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.multi_vehicle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 task_vehicle_num = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_task_vehicle_num(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_task_vehicle_num(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .haoxing.route.NodeXYZ service_nodes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_service_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanParam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.PlanParam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double inter_sp = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_inter_sp = this->_internal_inter_sp();
  uint64_t raw_inter_sp;
  memcpy(&raw_inter_sp, &tmp_inter_sp, sizeof(tmp_inter_sp));
  if (raw_inter_sp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_inter_sp(), target);
  }

  // double route_type = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_route_type = this->_internal_route_type();
  uint64_t raw_route_type;
  memcpy(&raw_route_type, &tmp_route_type, sizeof(tmp_route_type));
  if (raw_route_type != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_route_type(), target);
  }

  // double task_type = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_task_type = this->_internal_task_type();
  uint64_t raw_task_type;
  memcpy(&raw_task_type, &tmp_task_type, sizeof(tmp_task_type));
  if (raw_task_type != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_task_type(), target);
  }

  // bool modify_orientation = 4;
  if (this->_internal_modify_orientation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_modify_orientation(), target);
  }

  // bool acc_overlap = 5;
  if (this->_internal_acc_overlap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_acc_overlap(), target);
  }

  // bool multi_vehicle = 6;
  if (this->_internal_multi_vehicle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_multi_vehicle(), target);
  }

  // repeated int32 task_vehicle_num = 7;
  {
    int byte_size = _impl_._task_vehicle_num_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          7, _internal_task_vehicle_num(), byte_size, target);
    }
  }

  // repeated .haoxing.route.NodeXYZ service_nodes = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_service_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_service_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.PlanParam)
  return target;
}

size_t PlanParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.PlanParam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 task_vehicle_num = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.task_vehicle_num_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._task_vehicle_num_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .haoxing.route.NodeXYZ service_nodes = 8;
  total_size += 1UL * this->_internal_service_nodes_size();
  for (const auto& msg : this->_impl_.service_nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // double inter_sp = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_inter_sp = this->_internal_inter_sp();
  uint64_t raw_inter_sp;
  memcpy(&raw_inter_sp, &tmp_inter_sp, sizeof(tmp_inter_sp));
  if (raw_inter_sp != 0) {
    total_size += 1 + 8;
  }

  // double route_type = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_route_type = this->_internal_route_type();
  uint64_t raw_route_type;
  memcpy(&raw_route_type, &tmp_route_type, sizeof(tmp_route_type));
  if (raw_route_type != 0) {
    total_size += 1 + 8;
  }

  // double task_type = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_task_type = this->_internal_task_type();
  uint64_t raw_task_type;
  memcpy(&raw_task_type, &tmp_task_type, sizeof(tmp_task_type));
  if (raw_task_type != 0) {
    total_size += 1 + 8;
  }

  // bool modify_orientation = 4;
  if (this->_internal_modify_orientation() != 0) {
    total_size += 1 + 1;
  }

  // bool acc_overlap = 5;
  if (this->_internal_acc_overlap() != 0) {
    total_size += 1 + 1;
  }

  // bool multi_vehicle = 6;
  if (this->_internal_multi_vehicle() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanParam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanParam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanParam::GetClassData() const { return &_class_data_; }


void PlanParam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanParam*>(&to_msg);
  auto& from = static_cast<const PlanParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.PlanParam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.task_vehicle_num_.MergeFrom(from._impl_.task_vehicle_num_);
  _this->_impl_.service_nodes_.MergeFrom(from._impl_.service_nodes_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_inter_sp = from._internal_inter_sp();
  uint64_t raw_inter_sp;
  memcpy(&raw_inter_sp, &tmp_inter_sp, sizeof(tmp_inter_sp));
  if (raw_inter_sp != 0) {
    _this->_internal_set_inter_sp(from._internal_inter_sp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_route_type = from._internal_route_type();
  uint64_t raw_route_type;
  memcpy(&raw_route_type, &tmp_route_type, sizeof(tmp_route_type));
  if (raw_route_type != 0) {
    _this->_internal_set_route_type(from._internal_route_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_task_type = from._internal_task_type();
  uint64_t raw_task_type;
  memcpy(&raw_task_type, &tmp_task_type, sizeof(tmp_task_type));
  if (raw_task_type != 0) {
    _this->_internal_set_task_type(from._internal_task_type());
  }
  if (from._internal_modify_orientation() != 0) {
    _this->_internal_set_modify_orientation(from._internal_modify_orientation());
  }
  if (from._internal_acc_overlap() != 0) {
    _this->_internal_set_acc_overlap(from._internal_acc_overlap());
  }
  if (from._internal_multi_vehicle() != 0) {
    _this->_internal_set_multi_vehicle(from._internal_multi_vehicle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanParam::CopyFrom(const PlanParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.PlanParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanParam::IsInitialized() const {
  return true;
}

void PlanParam::InternalSwap(PlanParam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.task_vehicle_num_.InternalSwap(&other->_impl_.task_vehicle_num_);
  _impl_.service_nodes_.InternalSwap(&other->_impl_.service_nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanParam, _impl_.multi_vehicle_)
      + sizeof(PlanParam::_impl_.multi_vehicle_)
      - PROTOBUF_FIELD_OFFSET(PlanParam, _impl_.inter_sp_)>(
          reinterpret_cast<char*>(&_impl_.inter_sp_),
          reinterpret_cast<char*>(&other->_impl_.inter_sp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[2]);
}

// ===================================================================

class Vehicle::_Internal {
 public:
};

Vehicle::Vehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.Vehicle)
}
Vehicle::Vehicle(const Vehicle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vehicle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.length_){}
    , decltype(_impl_.over_all_width_){}
    , decltype(_impl_.front_end_to_location_){}
    , decltype(_impl_.rear_end_to_location_){}
    , decltype(_impl_.wheel_base_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.reverse_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.length_, &from._impl_.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reverse_) -
    reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.reverse_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.Vehicle)
}

inline void Vehicle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.length_){0}
    , decltype(_impl_.over_all_width_){0}
    , decltype(_impl_.front_end_to_location_){0}
    , decltype(_impl_.rear_end_to_location_){0}
    , decltype(_impl_.wheel_base_){0}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.reverse_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vehicle::~Vehicle() {
  // @@protoc_insertion_point(destructor:haoxing.route.Vehicle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vehicle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vehicle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vehicle::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.Vehicle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.reverse_) -
      reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.reverse_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vehicle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool reverse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double over_all_width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.over_all_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double front_end_to_location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.front_end_to_location_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rear_end_to_location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.rear_end_to_location_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double wheel_base = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.wheel_base_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double radius = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vehicle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.Vehicle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double length = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_length(), target);
  }

  // bool reverse = 2;
  if (this->_internal_reverse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_reverse(), target);
  }

  // double over_all_width = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_over_all_width = this->_internal_over_all_width();
  uint64_t raw_over_all_width;
  memcpy(&raw_over_all_width, &tmp_over_all_width, sizeof(tmp_over_all_width));
  if (raw_over_all_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_over_all_width(), target);
  }

  // double front_end_to_location = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_front_end_to_location = this->_internal_front_end_to_location();
  uint64_t raw_front_end_to_location;
  memcpy(&raw_front_end_to_location, &tmp_front_end_to_location, sizeof(tmp_front_end_to_location));
  if (raw_front_end_to_location != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_front_end_to_location(), target);
  }

  // double rear_end_to_location = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rear_end_to_location = this->_internal_rear_end_to_location();
  uint64_t raw_rear_end_to_location;
  memcpy(&raw_rear_end_to_location, &tmp_rear_end_to_location, sizeof(tmp_rear_end_to_location));
  if (raw_rear_end_to_location != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_rear_end_to_location(), target);
  }

  // double wheel_base = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_base = this->_internal_wheel_base();
  uint64_t raw_wheel_base;
  memcpy(&raw_wheel_base, &tmp_wheel_base, sizeof(tmp_wheel_base));
  if (raw_wheel_base != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_wheel_base(), target);
  }

  // double radius = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_radius = this->_internal_radius();
  uint64_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.Vehicle)
  return target;
}

size_t Vehicle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.Vehicle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double length = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 1 + 8;
  }

  // double over_all_width = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_over_all_width = this->_internal_over_all_width();
  uint64_t raw_over_all_width;
  memcpy(&raw_over_all_width, &tmp_over_all_width, sizeof(tmp_over_all_width));
  if (raw_over_all_width != 0) {
    total_size += 1 + 8;
  }

  // double front_end_to_location = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_front_end_to_location = this->_internal_front_end_to_location();
  uint64_t raw_front_end_to_location;
  memcpy(&raw_front_end_to_location, &tmp_front_end_to_location, sizeof(tmp_front_end_to_location));
  if (raw_front_end_to_location != 0) {
    total_size += 1 + 8;
  }

  // double rear_end_to_location = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rear_end_to_location = this->_internal_rear_end_to_location();
  uint64_t raw_rear_end_to_location;
  memcpy(&raw_rear_end_to_location, &tmp_rear_end_to_location, sizeof(tmp_rear_end_to_location));
  if (raw_rear_end_to_location != 0) {
    total_size += 1 + 8;
  }

  // double wheel_base = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_base = this->_internal_wheel_base();
  uint64_t raw_wheel_base;
  memcpy(&raw_wheel_base, &tmp_wheel_base, sizeof(tmp_wheel_base));
  if (raw_wheel_base != 0) {
    total_size += 1 + 8;
  }

  // double radius = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_radius = this->_internal_radius();
  uint64_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 1 + 8;
  }

  // bool reverse = 2;
  if (this->_internal_reverse() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vehicle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vehicle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vehicle::GetClassData() const { return &_class_data_; }


void Vehicle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vehicle*>(&to_msg);
  auto& from = static_cast<const Vehicle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.Vehicle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = from._internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_over_all_width = from._internal_over_all_width();
  uint64_t raw_over_all_width;
  memcpy(&raw_over_all_width, &tmp_over_all_width, sizeof(tmp_over_all_width));
  if (raw_over_all_width != 0) {
    _this->_internal_set_over_all_width(from._internal_over_all_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_front_end_to_location = from._internal_front_end_to_location();
  uint64_t raw_front_end_to_location;
  memcpy(&raw_front_end_to_location, &tmp_front_end_to_location, sizeof(tmp_front_end_to_location));
  if (raw_front_end_to_location != 0) {
    _this->_internal_set_front_end_to_location(from._internal_front_end_to_location());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rear_end_to_location = from._internal_rear_end_to_location();
  uint64_t raw_rear_end_to_location;
  memcpy(&raw_rear_end_to_location, &tmp_rear_end_to_location, sizeof(tmp_rear_end_to_location));
  if (raw_rear_end_to_location != 0) {
    _this->_internal_set_rear_end_to_location(from._internal_rear_end_to_location());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_base = from._internal_wheel_base();
  uint64_t raw_wheel_base;
  memcpy(&raw_wheel_base, &tmp_wheel_base, sizeof(tmp_wheel_base));
  if (raw_wheel_base != 0) {
    _this->_internal_set_wheel_base(from._internal_wheel_base());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_radius = from._internal_radius();
  uint64_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  if (from._internal_reverse() != 0) {
    _this->_internal_set_reverse(from._internal_reverse());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vehicle::CopyFrom(const Vehicle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.Vehicle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vehicle::IsInitialized() const {
  return true;
}

void Vehicle::InternalSwap(Vehicle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vehicle, _impl_.reverse_)
      + sizeof(Vehicle::_impl_.reverse_)
      - PROTOBUF_FIELD_OFFSET(Vehicle, _impl_.length_)>(
          reinterpret_cast<char*>(&_impl_.length_),
          reinterpret_cast<char*>(&other->_impl_.length_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vehicle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[3]);
}

// ===================================================================

class Implement::_Internal {
 public:
};

Implement::Implement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.Implement)
}
Implement::Implement(const Implement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Implement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){}
    , decltype(_impl_.length_){}
    , decltype(_impl_.right_offset_){}
    , decltype(_impl_.left_offset_){}
    , decltype(_impl_.linkage_mode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.linkage_mode_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.linkage_mode_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.Implement)
}

inline void Implement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){0}
    , decltype(_impl_.length_){0}
    , decltype(_impl_.right_offset_){0}
    , decltype(_impl_.left_offset_){0}
    , decltype(_impl_.linkage_mode_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Implement::~Implement() {
  // @@protoc_insertion_point(destructor:haoxing.route.Implement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Implement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Implement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Implement::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.Implement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.linkage_mode_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.linkage_mode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Implement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double right_offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.right_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double left_offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.left_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 linkage_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.linkage_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Implement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.Implement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double width = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_width(), target);
  }

  // double length = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_length(), target);
  }

  // double right_offset = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_offset = this->_internal_right_offset();
  uint64_t raw_right_offset;
  memcpy(&raw_right_offset, &tmp_right_offset, sizeof(tmp_right_offset));
  if (raw_right_offset != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_right_offset(), target);
  }

  // double left_offset = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_offset = this->_internal_left_offset();
  uint64_t raw_left_offset;
  memcpy(&raw_left_offset, &tmp_left_offset, sizeof(tmp_left_offset));
  if (raw_left_offset != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_left_offset(), target);
  }

  // int32 linkage_mode = 5;
  if (this->_internal_linkage_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_linkage_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.Implement)
  return target;
}

size_t Implement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.Implement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double width = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 8;
  }

  // double length = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 1 + 8;
  }

  // double right_offset = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_offset = this->_internal_right_offset();
  uint64_t raw_right_offset;
  memcpy(&raw_right_offset, &tmp_right_offset, sizeof(tmp_right_offset));
  if (raw_right_offset != 0) {
    total_size += 1 + 8;
  }

  // double left_offset = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_offset = this->_internal_left_offset();
  uint64_t raw_left_offset;
  memcpy(&raw_left_offset, &tmp_left_offset, sizeof(tmp_left_offset));
  if (raw_left_offset != 0) {
    total_size += 1 + 8;
  }

  // int32 linkage_mode = 5;
  if (this->_internal_linkage_mode() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_linkage_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Implement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Implement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Implement::GetClassData() const { return &_class_data_; }


void Implement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Implement*>(&to_msg);
  auto& from = static_cast<const Implement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.Implement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = from._internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = from._internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_offset = from._internal_right_offset();
  uint64_t raw_right_offset;
  memcpy(&raw_right_offset, &tmp_right_offset, sizeof(tmp_right_offset));
  if (raw_right_offset != 0) {
    _this->_internal_set_right_offset(from._internal_right_offset());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_offset = from._internal_left_offset();
  uint64_t raw_left_offset;
  memcpy(&raw_left_offset, &tmp_left_offset, sizeof(tmp_left_offset));
  if (raw_left_offset != 0) {
    _this->_internal_set_left_offset(from._internal_left_offset());
  }
  if (from._internal_linkage_mode() != 0) {
    _this->_internal_set_linkage_mode(from._internal_linkage_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Implement::CopyFrom(const Implement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.Implement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Implement::IsInitialized() const {
  return true;
}

void Implement::InternalSwap(Implement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Implement, _impl_.linkage_mode_)
      + sizeof(Implement::_impl_.linkage_mode_)
      - PROTOBUF_FIELD_OFFSET(Implement, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Implement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[4]);
}

// ===================================================================

class Obstacle::_Internal {
 public:
};

Obstacle::Obstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Obstacle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.r_){}
    , decltype(_impl_.r_w_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.r_w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.r_w_));
  // @@protoc_insertion_point(copy_constructor:haoxing.route.Obstacle)
}

inline void Obstacle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.r_){0}
    , decltype(_impl_.r_w_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:haoxing.route.Obstacle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Obstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Obstacle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.Obstacle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.r_w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.r_w_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Obstacle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double r = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double r_w = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.r_w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Obstacle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.Obstacle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double r = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = this->_internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_r(), target);
  }

  // double r_w = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r_w = this->_internal_r_w();
  uint64_t raw_r_w;
  memcpy(&raw_r_w, &tmp_r_w, sizeof(tmp_r_w));
  if (raw_r_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_r_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.Obstacle)
  return target;
}

size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.Obstacle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double r = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = this->_internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    total_size += 1 + 8;
  }

  // double r_w = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r_w = this->_internal_r_w();
  uint64_t raw_r_w;
  memcpy(&raw_r_w, &tmp_r_w, sizeof(tmp_r_w));
  if (raw_r_w != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Obstacle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Obstacle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Obstacle::GetClassData() const { return &_class_data_; }


void Obstacle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Obstacle*>(&to_msg);
  auto& from = static_cast<const Obstacle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.Obstacle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = from._internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r_w = from._internal_r_w();
  uint64_t raw_r_w;
  memcpy(&raw_r_w, &tmp_r_w, sizeof(tmp_r_w));
  if (raw_r_w != 0) {
    _this->_internal_set_r_w(from._internal_r_w());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  return true;
}

void Obstacle::InternalSwap(Obstacle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Obstacle, _impl_.r_w_)
      + sizeof(Obstacle::_impl_.r_w_)
      - PROTOBUF_FIELD_OFFSET(Obstacle, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Obstacle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[5]);
}

// ===================================================================

class RequestParam::_Internal {
 public:
  static const ::haoxing::route::PlanParam& plan_param(const RequestParam* msg);
  static const ::haoxing::route::Vehicle& vehicle(const RequestParam* msg);
  static const ::haoxing::route::Implement& implement(const RequestParam* msg);
};

const ::haoxing::route::PlanParam&
RequestParam::_Internal::plan_param(const RequestParam* msg) {
  return *msg->_impl_.plan_param_;
}
const ::haoxing::route::Vehicle&
RequestParam::_Internal::vehicle(const RequestParam* msg) {
  return *msg->_impl_.vehicle_;
}
const ::haoxing::route::Implement&
RequestParam::_Internal::implement(const RequestParam* msg) {
  return *msg->_impl_.implement_;
}
RequestParam::RequestParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.RequestParam)
}
RequestParam::RequestParam(const RequestParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.field_infos_){from._impl_.field_infos_}
    , decltype(_impl_.plan_param_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.implement_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_plan_param()) {
    _this->_impl_.plan_param_ = new ::haoxing::route::PlanParam(*from._impl_.plan_param_);
  }
  if (from._internal_has_vehicle()) {
    _this->_impl_.vehicle_ = new ::haoxing::route::Vehicle(*from._impl_.vehicle_);
  }
  if (from._internal_has_implement()) {
    _this->_impl_.implement_ = new ::haoxing::route::Implement(*from._impl_.implement_);
  }
  // @@protoc_insertion_point(copy_constructor:haoxing.route.RequestParam)
}

inline void RequestParam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.field_infos_){arena}
    , decltype(_impl_.plan_param_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.implement_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RequestParam::~RequestParam() {
  // @@protoc_insertion_point(destructor:haoxing.route.RequestParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestParam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.field_infos_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.plan_param_;
  if (this != internal_default_instance()) delete _impl_.vehicle_;
  if (this != internal_default_instance()) delete _impl_.implement_;
}

void RequestParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestParam::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.RequestParam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.field_infos_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.plan_param_ != nullptr) {
    delete _impl_.plan_param_;
  }
  _impl_.plan_param_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.implement_ != nullptr) {
    delete _impl_.implement_;
  }
  _impl_.implement_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .haoxing.route.FieldInfo field_infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_field_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.PlanParam plan_param = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_plan_param(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.Vehicle vehicle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_vehicle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .haoxing.route.Implement implement = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_implement(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestParam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.RequestParam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .haoxing.route.FieldInfo field_infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_field_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_field_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .haoxing.route.PlanParam plan_param = 2;
  if (this->_internal_has_plan_param()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::plan_param(this),
        _Internal::plan_param(this).GetCachedSize(), target, stream);
  }

  // .haoxing.route.Vehicle vehicle = 3;
  if (this->_internal_has_vehicle()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::vehicle(this),
        _Internal::vehicle(this).GetCachedSize(), target, stream);
  }

  // .haoxing.route.Implement implement = 4;
  if (this->_internal_has_implement()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::implement(this),
        _Internal::implement(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.RequestParam)
  return target;
}

size_t RequestParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.RequestParam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .haoxing.route.FieldInfo field_infos = 1;
  total_size += 1UL * this->_internal_field_infos_size();
  for (const auto& msg : this->_impl_.field_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .haoxing.route.PlanParam plan_param = 2;
  if (this->_internal_has_plan_param()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.plan_param_);
  }

  // .haoxing.route.Vehicle vehicle = 3;
  if (this->_internal_has_vehicle()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vehicle_);
  }

  // .haoxing.route.Implement implement = 4;
  if (this->_internal_has_implement()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.implement_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestParam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestParam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestParam::GetClassData() const { return &_class_data_; }


void RequestParam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestParam*>(&to_msg);
  auto& from = static_cast<const RequestParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.RequestParam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.field_infos_.MergeFrom(from._impl_.field_infos_);
  if (from._internal_has_plan_param()) {
    _this->_internal_mutable_plan_param()->::haoxing::route::PlanParam::MergeFrom(
        from._internal_plan_param());
  }
  if (from._internal_has_vehicle()) {
    _this->_internal_mutable_vehicle()->::haoxing::route::Vehicle::MergeFrom(
        from._internal_vehicle());
  }
  if (from._internal_has_implement()) {
    _this->_internal_mutable_implement()->::haoxing::route::Implement::MergeFrom(
        from._internal_implement());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestParam::CopyFrom(const RequestParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.RequestParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestParam::IsInitialized() const {
  return true;
}

void RequestParam::InternalSwap(RequestParam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.field_infos_.InternalSwap(&other->_impl_.field_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestParam, _impl_.implement_)
      + sizeof(RequestParam::_impl_.implement_)
      - PROTOBUF_FIELD_OFFSET(RequestParam, _impl_.plan_param_)>(
          reinterpret_cast<char*>(&_impl_.plan_param_),
          reinterpret_cast<char*>(&other->_impl_.plan_param_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[6]);
}

// ===================================================================

class ResponseParam::_Internal {
 public:
};

ResponseParam::ResponseParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:haoxing.route.ResponseParam)
}
ResponseParam::ResponseParam(const ResponseParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , decltype(_impl_.mileage_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.mileage_ = from._impl_.mileage_;
  // @@protoc_insertion_point(copy_constructor:haoxing.route.ResponseParam)
}

inline void ResponseParam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , decltype(_impl_.mileage_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResponseParam::~ResponseParam() {
  // @@protoc_insertion_point(destructor:haoxing.route.ResponseParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseParam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void ResponseParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseParam::Clear() {
// @@protoc_insertion_point(message_clear_start:haoxing.route.ResponseParam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _impl_.mileage_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .haoxing.route.NodeXYZ nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double mileage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.mileage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseParam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:haoxing.route.ResponseParam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .haoxing.route.NodeXYZ nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // double mileage = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mileage = this->_internal_mileage();
  uint64_t raw_mileage;
  memcpy(&raw_mileage, &tmp_mileage, sizeof(tmp_mileage));
  if (raw_mileage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_mileage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:haoxing.route.ResponseParam)
  return target;
}

size_t ResponseParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:haoxing.route.ResponseParam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .haoxing.route.NodeXYZ nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // double mileage = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mileage = this->_internal_mileage();
  uint64_t raw_mileage;
  memcpy(&raw_mileage, &tmp_mileage, sizeof(tmp_mileage));
  if (raw_mileage != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseParam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseParam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseParam::GetClassData() const { return &_class_data_; }


void ResponseParam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseParam*>(&to_msg);
  auto& from = static_cast<const ResponseParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:haoxing.route.ResponseParam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mileage = from._internal_mileage();
  uint64_t raw_mileage;
  memcpy(&raw_mileage, &tmp_mileage, sizeof(tmp_mileage));
  if (raw_mileage != 0) {
    _this->_internal_set_mileage(from._internal_mileage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseParam::CopyFrom(const ResponseParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:haoxing.route.ResponseParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseParam::IsInitialized() const {
  return true;
}

void ResponseParam::InternalSwap(ResponseParam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  swap(_impl_.mileage_, other->_impl_.mileage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_route_2eproto_getter, &descriptor_table_route_2eproto_once,
      file_level_metadata_route_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace route
}  // namespace haoxing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::haoxing::route::NodeXYZ*
Arena::CreateMaybeMessage< ::haoxing::route::NodeXYZ >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::NodeXYZ >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::FieldInfo*
Arena::CreateMaybeMessage< ::haoxing::route::FieldInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::FieldInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::PlanParam*
Arena::CreateMaybeMessage< ::haoxing::route::PlanParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::PlanParam >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::Vehicle*
Arena::CreateMaybeMessage< ::haoxing::route::Vehicle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::Vehicle >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::Implement*
Arena::CreateMaybeMessage< ::haoxing::route::Implement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::Implement >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::Obstacle*
Arena::CreateMaybeMessage< ::haoxing::route::Obstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::Obstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::RequestParam*
Arena::CreateMaybeMessage< ::haoxing::route::RequestParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::RequestParam >(arena);
}
template<> PROTOBUF_NOINLINE ::haoxing::route::ResponseParam*
Arena::CreateMaybeMessage< ::haoxing::route::ResponseParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::haoxing::route::ResponseParam >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
